{
  "version": 3,
  "sources": ["../../geodesy/utm.js", "../../geodesy/mgrs.js"],
  "sourcesContent": ["/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/* UTM / WGS-84 Conversion Functions                                  (c) Chris Veness 2014-2019  */\n/*                                                                                   MIT Licence  */\n/* www.movable-type.co.uk/scripts/latlong-utm-mgrs.html                                           */\n/* www.movable-type.co.uk/scripts/geodesy-library.html#utm                                        */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n/* eslint-disable indent */\n\nimport LatLonEllipsoidal, { Dms } from './latlon-ellipsoidal-datum.js';\n\n\n/**\n * The Universal Transverse Mercator (UTM) system is a 2-dimensional Cartesian coordinate system\n * providing locations on the surface of the Earth.\n *\n * UTM is a set of 60 transverse Mercator projections, normally based on the WGS-84 ellipsoid.\n * Within each zone, coordinates are represented as eastings and northings, measures in metres; e.g.\n * ‘31 N 448251 5411932’.\n *\n * This method based on Karney 2011 ‘Transverse Mercator with an accuracy of a few nanometers’,\n * building on Krüger 1912 ‘Konforme Abbildung des Erdellipsoids in der Ebene’.\n *\n * @module utm\n */\n\n\n/* Utm  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n\n/**\n * UTM coordinates, with functions to parse them and convert them to LatLon points.\n */\nclass Utm {\n\n    /**\n     * Creates a Utm coordinate object comprising zone, hemisphere, easting, northing on a given\n     * datum (normally WGS84).\n     *\n     * @param  {number}        zone - UTM 6° longitudinal zone (1..60 covering 180°W..180°E).\n     * @param  {string}        hemisphere - N for northern hemisphere, S for southern hemisphere.\n     * @param  {number}        easting - Easting in metres from false easting (-500km from central meridian).\n     * @param  {number}        northing - Northing in metres from equator (N) or from false northing -10,000km (S).\n     * @param  {LatLon.datums} [datum=WGS84] - Datum UTM coordinate is based on.\n     * @param  {number}        [convergence=null] - Meridian convergence (bearing of grid north\n     *                         clockwise from true north), in degrees.\n     * @param  {number}        [scale=null] - Grid scale factor.\n     * @params {boolean=true}  verifyEN - Check easting/northing is within 'normal' values (may be\n     *                         suppressed for extended coherent coordinates or alternative datums\n     *                         e.g. ED50 (epsg.io/23029).\n     * @throws {TypeError} Invalid UTM coordinate.\n     *\n     * @example\n     *   import Utm from '/js/geodesy/utm.js';\n     *   const utmCoord = new Utm(31, 'N', 448251, 5411932);\n     */\n    constructor(zone, hemisphere, easting, northing, datum=LatLonEllipsoidal.datums.WGS84, convergence=null, scale=null, verifyEN=true) {\n        if (!(1<=zone && zone<=60)) throw new RangeError(`invalid UTM zone ‘${zone}’`);\n        if (zone != parseInt(zone)) throw new RangeError(`invalid UTM zone ‘${zone}’`);\n        if (typeof hemisphere != 'string' || !hemisphere.match(/[NS]/i)) throw new RangeError(`invalid UTM hemisphere ‘${hemisphere}’`);\n        if (verifyEN) { // range-check E/N values\n            if (!(0<=easting && easting<=1000e3)) throw new RangeError(`invalid UTM easting ‘${easting}’`);\n            if (hemisphere.toUpperCase()=='N' && !(0<=northing && northing<9328094)) throw new RangeError(`invalid UTM northing ‘${northing}’`);\n            if (hemisphere.toUpperCase()=='S' && !(1118414<northing && northing<=10000e3)) throw new RangeError(`invalid UTM northing ‘${northing}’`);\n        }\n        if (!datum || datum.ellipsoid==undefined) throw new TypeError(`unrecognised datum ‘${datum}’`);\n\n        this.zone = Number(zone);\n        this.hemisphere = hemisphere.toUpperCase();\n        this.easting = Number(easting);\n        this.northing = Number(northing);\n        this.datum = datum;\n        this.convergence = convergence===null ? null : Number(convergence);\n        this.scale = scale===null ? null : Number(scale);\n    }\n\n\n    /**\n     * Converts UTM zone/easting/northing coordinate to latitude/longitude.\n     *\n     * Implements Karney’s method, using Krüger series to order n⁶, giving results accurate to 5nm\n     * for distances up to 3900km from the central meridian.\n     *\n     * @param   {Utm} utmCoord - UTM coordinate to be converted to latitude/longitude.\n     * @returns {LatLon} Latitude/longitude of supplied grid reference.\n     *\n     * @example\n     *   const grid = new Utm(31, 'N', 448251.795, 5411932.678);\n     *   const latlong = grid.toLatLon(); // 48°51′29.52″N, 002°17′40.20″E\n     */\n    toLatLon() {\n        const { zone: z, hemisphere: h } = this;\n\n        const falseEasting = 500e3, falseNorthing = 10000e3;\n\n        const { a, f } = this.datum.ellipsoid; // WGS-84: a = 6378137, f = 1/298.257223563;\n\n        const k0 = 0.9996; // UTM scale on the central meridian\n\n        const x = this.easting - falseEasting;                            // make x ± relative to central meridian\n        const y = h=='S' ? this.northing - falseNorthing : this.northing; // make y ± relative to equator\n\n        // ---- from Karney 2011 Eq 15-22, 36:\n\n        const e = Math.sqrt(f*(2-f)); // eccentricity\n        const n = f / (2 - f);        // 3rd flattening\n        const n2 = n*n, n3 = n*n2, n4 = n*n3, n5 = n*n4, n6 = n*n5;\n\n        const A = a/(1+n) * (1 + 1/4*n2 + 1/64*n4 + 1/256*n6); // 2πA is the circumference of a meridian\n\n        const η = x / (k0*A);\n        const ξ = y / (k0*A);\n\n        const β = [ null, // note β is one-based array (6th order Krüger expressions)\n            1/2*n - 2/3*n2 + 37/96*n3 -    1/360*n4 -   81/512*n5 +    96199/604800*n6,\n                   1/48*n2 +  1/15*n3 - 437/1440*n4 +   46/105*n5 - 1118711/3870720*n6,\n                            17/480*n3 -   37/840*n4 - 209/4480*n5 +      5569/90720*n6,\n                                     4397/161280*n4 -   11/504*n5 -  830251/7257600*n6,\n                                                   4583/161280*n5 -  108847/3991680*n6,\n                                                                 20648693/638668800*n6 ];\n\n        let ξʹ = ξ;\n        for (let j=1; j<=6; j++) ξʹ -= β[j] * Math.sin(2*j*ξ) * Math.cosh(2*j*η);\n\n        let ηʹ = η;\n        for (let j=1; j<=6; j++) ηʹ -= β[j] * Math.cos(2*j*ξ) * Math.sinh(2*j*η);\n\n        const sinhηʹ = Math.sinh(ηʹ);\n        const sinξʹ = Math.sin(ξʹ), cosξʹ = Math.cos(ξʹ);\n\n        const τʹ = sinξʹ / Math.sqrt(sinhηʹ*sinhηʹ + cosξʹ*cosξʹ);\n\n        let δτi = null;\n        let τi = τʹ;\n        do {\n            const σi = Math.sinh(e*Math.atanh(e*τi/Math.sqrt(1+τi*τi)));\n            const τiʹ = τi * Math.sqrt(1+σi*σi) - σi * Math.sqrt(1+τi*τi);\n            δτi = (τʹ - τiʹ)/Math.sqrt(1+τiʹ*τiʹ)\n                * (1 + (1-e*e)*τi*τi) / ((1-e*e)*Math.sqrt(1+τi*τi));\n            τi += δτi;\n        } while (Math.abs(δτi) > 1e-12); // using IEEE 754 δτi -> 0 after 2-3 iterations\n        // note relatively large convergence test as δτi toggles on ±1.12e-16 for eg 31 N 400000 5000000\n        const τ = τi;\n\n        const φ = Math.atan(τ);\n\n        let λ = Math.atan2(sinhηʹ, cosξʹ);\n\n        // ---- convergence: Karney 2011 Eq 26, 27\n\n        let p = 1;\n        for (let j=1; j<=6; j++) p -= 2*j*β[j] * Math.cos(2*j*ξ) * Math.cosh(2*j*η);\n        let q = 0;\n        for (let j=1; j<=6; j++) q += 2*j*β[j] * Math.sin(2*j*ξ) * Math.sinh(2*j*η);\n\n        const γʹ = Math.atan(Math.tan(ξʹ) * Math.tanh(ηʹ));\n        const γʺ = Math.atan2(q, p);\n\n        const γ = γʹ + γʺ;\n\n        // ---- scale: Karney 2011 Eq 28\n\n        const sinφ = Math.sin(φ);\n        const kʹ = Math.sqrt(1 - e*e*sinφ*sinφ) * Math.sqrt(1 + τ*τ) * Math.sqrt(sinhηʹ*sinhηʹ + cosξʹ*cosξʹ);\n        const kʺ = A / a / Math.sqrt(p*p + q*q);\n\n        const k = k0 * kʹ * kʺ;\n\n        // ------------\n\n        const λ0 = ((z-1)*6 - 180 + 3).toRadians(); // longitude of central meridian\n        λ += λ0; // move λ from zonal to global coordinates\n\n        // round to reasonable precision\n        const lat = Number(φ.toDegrees().toFixed(14)); // nm precision (1nm = 10^-14°)\n        const lon = Number(λ.toDegrees().toFixed(14)); // (strictly lat rounding should be φ⋅cosφ!)\n        const convergence = Number(γ.toDegrees().toFixed(9));\n        const scale = Number(k.toFixed(12));\n\n        const latLong = new LatLon_Utm(lat, lon, 0, this.datum);\n        // ... and add the convergence and scale into the LatLon object ... wonderful JavaScript!\n        latLong.convergence = convergence;\n        latLong.scale = scale;\n\n        return latLong;\n    }\n\n\n    /**\n     * Parses string representation of UTM coordinate.\n     *\n     * A UTM coordinate comprises (space-separated)\n     *  - zone\n     *  - hemisphere\n     *  - easting\n     *  - northing.\n     *\n     * @param   {string} utmCoord - UTM coordinate (WGS 84).\n     * @param   {Datum}  [datum=WGS84] - Datum coordinate is defined in (default WGS 84).\n     * @returns {Utm} Parsed UTM coordinate.\n     * @throws  {TypeError} Invalid UTM coordinate.\n     *\n     * @example\n     *   const utmCoord = Utm.parse('31 N 448251 5411932');\n     *   // utmCoord: {zone: 31, hemisphere: 'N', easting: 448251, northing: 5411932 }\n     */\n    static parse(utmCoord, datum=LatLonEllipsoidal.datums.WGS84) {\n        // match separate elements (separated by whitespace)\n        utmCoord = utmCoord.trim().match(/\\S+/g);\n\n        if (utmCoord==null || utmCoord.length!=4) throw new Error(`invalid UTM coordinate ‘${utmCoord}’`);\n\n        const zone = utmCoord[0], hemisphere = utmCoord[1], easting = utmCoord[2], northing = utmCoord[3];\n\n        return new this(zone, hemisphere, easting, northing, datum); // 'new this' as may return subclassed types\n    }\n\n\n    /**\n     * Returns a string representation of a UTM coordinate.\n     *\n     * To distinguish from MGRS grid zone designators, a space is left between the zone and the\n     * hemisphere.\n     *\n     * Note that UTM coordinates get rounded, not truncated (unlike MGRS grid references).\n     *\n     * @param   {number} [digits=0] - Number of digits to appear after the decimal point (3 ≡ mm).\n     * @returns {string} A string representation of the coordinate.\n     *\n     * @example\n     *   const utm = new Utm('31', 'N', 448251, 5411932).toString(4);  // 31 N 448251.0000 5411932.0000\n     */\n    toString(digits=0) {\n\n        const z = this.zone.toString().padStart(2, '0');\n        const h = this.hemisphere;\n        const e = this.easting.toFixed(digits);\n        const n = this.northing.toFixed(digits);\n\n        return `${z} ${h} ${e} ${n}`;\n    }\n\n}\n\n\n/* LatLon_Utm - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n\n/**\n * Extends LatLon with method to convert LatLon points to UTM coordinates.\n *\n * @extends LatLon\n */\nclass LatLon_Utm extends LatLonEllipsoidal {\n\n    /**\n     * Converts latitude/longitude to UTM coordinate.\n     *\n     * Implements Karney’s method, using Krüger series to order n⁶, giving results accurate to 5nm\n     * for distances up to 3900km from the central meridian.\n     *\n     * @param   {number} [zoneOverride] - Use specified zone rather than zone within which point lies;\n     *          note overriding the UTM zone has the potential to result in negative eastings, and\n     *          perverse results within Norway/Svalbard exceptions.\n     * @returns {Utm} UTM coordinate.\n     * @throws  {TypeError} Latitude outside UTM limits.\n     *\n     * @example\n     *   const latlong = new LatLon(48.8582, 2.2945);\n     *   const utmCoord = latlong.toUtm(); // 31 N 448252 5411933\n     */\n    toUtm(zoneOverride=undefined) {\n        if (!(-80<=this.lat && this.lat<=84)) throw new RangeError(`latitude ‘${this.lat}’ outside UTM limits`);\n\n        const falseEasting = 500e3, falseNorthing = 10000e3;\n\n        let zone = zoneOverride || Math.floor((this.lon+180)/6) + 1; // longitudinal zone\n        let λ0 = ((zone-1)*6 - 180 + 3).toRadians(); // longitude of central meridian\n\n        // ---- handle Norway/Svalbard exceptions\n        // grid zones are 8° tall; 0°N is offset 10 into latitude bands array\n        const mgrsLatBands = 'CDEFGHJKLMNPQRSTUVWXX'; // X is repeated for 80-84°N\n        const latBand = mgrsLatBands.charAt(Math.floor(this.lat/8+10));\n        // adjust zone & central meridian for Norway\n        if (zone==31 && latBand=='V' && this.lon>= 3) { zone++; λ0 += (6).toRadians(); }\n        // adjust zone & central meridian for Svalbard\n        if (zone==32 && latBand=='X' && this.lon<  9) { zone--; λ0 -= (6).toRadians(); }\n        if (zone==32 && latBand=='X' && this.lon>= 9) { zone++; λ0 += (6).toRadians(); }\n        if (zone==34 && latBand=='X' && this.lon< 21) { zone--; λ0 -= (6).toRadians(); }\n        if (zone==34 && latBand=='X' && this.lon>=21) { zone++; λ0 += (6).toRadians(); }\n        if (zone==36 && latBand=='X' && this.lon< 33) { zone--; λ0 -= (6).toRadians(); }\n        if (zone==36 && latBand=='X' && this.lon>=33) { zone++; λ0 += (6).toRadians(); }\n\n        const φ = this.lat.toRadians();      // latitude ± from equator\n        const λ = this.lon.toRadians() - λ0; // longitude ± from central meridian\n\n        // allow alternative ellipsoid to be specified\n        const ellipsoid = this.datum ? this.datum.ellipsoid : LatLonEllipsoidal.ellipsoids.WGS84;\n        const { a, f } = ellipsoid; // WGS-84: a = 6378137, f = 1/298.257223563;\n\n        const k0 = 0.9996; // UTM scale on the central meridian\n\n        // ---- easting, northing: Karney 2011 Eq 7-14, 29, 35:\n\n        const e = Math.sqrt(f*(2-f)); // eccentricity\n        const n = f / (2 - f);        // 3rd flattening\n        const n2 = n*n, n3 = n*n2, n4 = n*n3, n5 = n*n4, n6 = n*n5;\n\n        const cosλ = Math.cos(λ), sinλ = Math.sin(λ), tanλ = Math.tan(λ);\n\n        const τ = Math.tan(φ); // τ ≡ tanφ, τʹ ≡ tanφʹ; prime (ʹ) indicates angles on the conformal sphere\n        const σ = Math.sinh(e*Math.atanh(e*τ/Math.sqrt(1+τ*τ)));\n\n        const τʹ = τ*Math.sqrt(1+σ*σ) - σ*Math.sqrt(1+τ*τ);\n\n        const ξʹ = Math.atan2(τʹ, cosλ);\n        const ηʹ = Math.asinh(sinλ / Math.sqrt(τʹ*τʹ + cosλ*cosλ));\n\n        const A = a/(1+n) * (1 + 1/4*n2 + 1/64*n4 + 1/256*n6); // 2πA is the circumference of a meridian\n\n        const α = [ null, // note α is one-based array (6th order Krüger expressions)\n            1/2*n - 2/3*n2 + 5/16*n3 +   41/180*n4 -     127/288*n5 +      7891/37800*n6,\n                  13/48*n2 -  3/5*n3 + 557/1440*n4 +     281/630*n5 - 1983433/1935360*n6,\n                           61/240*n3 -  103/140*n4 + 15061/26880*n5 +   167603/181440*n6,\n                                   49561/161280*n4 -     179/168*n5 + 6601661/7257600*n6,\n                                                     34729/80640*n5 - 3418889/1995840*n6,\n                                                                  212378941/319334400*n6 ];\n\n        let ξ = ξʹ;\n        for (let j=1; j<=6; j++) ξ += α[j] * Math.sin(2*j*ξʹ) * Math.cosh(2*j*ηʹ);\n\n        let η = ηʹ;\n        for (let j=1; j<=6; j++) η += α[j] * Math.cos(2*j*ξʹ) * Math.sinh(2*j*ηʹ);\n\n        let x = k0 * A * η;\n        let y = k0 * A * ξ;\n\n        // ---- convergence: Karney 2011 Eq 23, 24\n\n        let pʹ = 1;\n        for (let j=1; j<=6; j++) pʹ += 2*j*α[j] * Math.cos(2*j*ξʹ) * Math.cosh(2*j*ηʹ);\n        let qʹ = 0;\n        for (let j=1; j<=6; j++) qʹ += 2*j*α[j] * Math.sin(2*j*ξʹ) * Math.sinh(2*j*ηʹ);\n\n        const γʹ = Math.atan(τʹ / Math.sqrt(1+τʹ*τʹ)*tanλ);\n        const γʺ = Math.atan2(qʹ, pʹ);\n\n        const γ = γʹ + γʺ;\n\n        // ---- scale: Karney 2011 Eq 25\n\n        const sinφ = Math.sin(φ);\n        const kʹ = Math.sqrt(1 - e*e*sinφ*sinφ) * Math.sqrt(1 + τ*τ) / Math.sqrt(τʹ*τʹ + cosλ*cosλ);\n        const kʺ = A / a * Math.sqrt(pʹ*pʹ + qʹ*qʹ);\n\n        const k = k0 * kʹ * kʺ;\n\n        // ------------\n\n        // shift x/y to false origins\n        x = x + falseEasting;             // make x relative to false easting\n        if (y < 0) y = y + falseNorthing; // make y in southern hemisphere relative to false northing\n\n        // round to reasonable precision\n        x = Number(x.toFixed(9)); // nm precision\n        y = Number(y.toFixed(9)); // nm precision\n        const convergence = Number(γ.toDegrees().toFixed(9));\n        const scale = Number(k.toFixed(12));\n\n        const h = this.lat>=0 ? 'N' : 'S'; // hemisphere\n\n        return new Utm(zone, h, x, y, this.datum, convergence, scale, !!zoneOverride);\n    }\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nexport { Utm as default, LatLon_Utm as LatLon, Dms };\n", "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/* MGRS / UTM Conversion Functions                                    (c) Chris Veness 2014-2019  */\n/*                                                                                   MIT Licence  */\n/* www.movable-type.co.uk/scripts/latlong-utm-mgrs.html                                           */\n/* www.movable-type.co.uk/scripts/geodesy-library.html#mgrs                                       */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nimport Utm, { LatLon as LatLonEllipsoidal, Dms } from './utm.js';\n\n\n/**\n * Military Grid Reference System (MGRS/NATO) grid references provides geocoordinate references\n * covering the entire globe, based on UTM projections.\n *\n * MGRS references comprise a grid zone designator, a 100km square identification, and an easting\n * and northing (in metres); e.g. ‘31U DQ 48251 11932’.\n *\n * Depending on requirements, some parts of the reference may be omitted (implied), and\n * eastings/northings may be given to varying resolution.\n *\n * qv www.fgdc.gov/standards/projects/FGDC-standards-projects/usng/fgdc_std_011_2001_usng.pdf\n *\n * @module mgrs\n */\n\n\n/*\n * Latitude bands C..X 8° each, covering 80°S to 84°N\n */\nconst latBands = 'CDEFGHJKLMNPQRSTUVWXX'; // X is repeated for 80-84°N\n\n\n/*\n * 100km grid square column (‘e’) letters repeat every third zone\n */\nconst e100kLetters = [ 'ABCDEFGH', 'JKLMNPQR', 'STUVWXYZ' ];\n\n\n/*\n * 100km grid square row (‘n’) letters repeat every other zone\n */\nconst n100kLetters = [ 'ABCDEFGHJKLMNPQRSTUV', 'FGHJKLMNPQRSTUVABCDE' ];\n\n\n/* Mgrs - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n\n/**\n * Military Grid Reference System (MGRS/NATO) grid references, with methods to parse references, and\n * to convert to UTM coordinates.\n */\nclass Mgrs {\n\n    /**\n     * Creates an Mgrs grid reference object.\n     *\n     * @param  {number} zone - 6° longitudinal zone (1..60 covering 180°W..180°E).\n     * @param  {string} band - 8° latitudinal band (C..X covering 80°S..84°N).\n     * @param  {string} e100k - First letter (E) of 100km grid square.\n     * @param  {string} n100k - Second letter (N) of 100km grid square.\n     * @param  {number} easting - Easting in metres within 100km grid square.\n     * @param  {number} northing - Northing in metres within 100km grid square.\n     * @param  {LatLon.datums} [datum=WGS84] - Datum UTM coordinate is based on.\n     * @throws {RangeError}  Invalid MGRS grid reference.\n     *\n     * @example\n     *   import Mgrs from '/js/geodesy/mgrs.js';\n     *   const mgrsRef = new Mgrs(31, 'U', 'D', 'Q', 48251, 11932); // 31U DQ 48251 11932\n     */\n    constructor(zone, band, e100k, n100k, easting, northing, datum=LatLonEllipsoidal.datums.WGS84) {\n        if (!(1<=zone && zone<=60)) throw new RangeError(`invalid MGRS zone ‘${zone}’`);\n        if (zone != parseInt(zone)) throw new RangeError(`invalid MGRS zone ‘${zone}’`);\n        const errors = []; // check & report all other possible errors rather than reporting one-by-one\n        if (band.length!=1 || latBands.indexOf(band) == -1) errors.push(`invalid MGRS band ‘${band}’`);\n        if (e100k.length!=1 || e100kLetters[(zone-1)%3].indexOf(e100k) == -1) errors.push(`invalid MGRS 100km grid square column ‘${e100k}’ for zone ${zone}`);\n        if (n100k.length!=1 || n100kLetters[0].indexOf(n100k) == -1) errors.push(`invalid MGRS 100km grid square row ‘${n100k}’`);\n        if (isNaN(Number(easting))) errors.push(`invalid MGRS easting ‘${easting}’`);\n        if (isNaN(Number(northing))) errors.push(`invalid MGRS northing ‘${northing}’`);\n        if (!datum || datum.ellipsoid==undefined) errors.push(`unrecognised datum ‘${datum}’`);\n        if (errors.length > 0) throw new RangeError(errors.join(', '));\n\n        this.zone = Number(zone);\n        this.band = band;\n        this.e100k = e100k;\n        this.n100k = n100k;\n        this.easting = Number(easting);\n        this.northing = Number(northing);\n        this.datum = datum;\n    }\n\n\n    /**\n     * Converts MGRS grid reference to UTM coordinate.\n     *\n     * Grid references refer to squares rather than points (with the size of the square indicated\n     * by the precision of the reference); this conversion will return the UTM coordinate of the SW\n     * corner of the grid reference square.\n     *\n     * @returns {Utm} UTM coordinate of SW corner of this MGRS grid reference.\n     *\n     * @example\n     *   const mgrsRef = Mgrs.parse('31U DQ 48251 11932');\n     *   const utmCoord = mgrsRef.toUtm(); // 31 N 448251 5411932\n     */\n    toUtm() {\n        const hemisphere = this.band>='N' ? 'N' : 'S';\n\n        // get easting specified by e100k (note +1 because eastings start at 166e3 due to 500km false origin)\n        const col = e100kLetters[(this.zone-1)%3].indexOf(this.e100k) + 1;\n        const e100kNum = col * 100e3; // e100k in metres\n\n        // get northing specified by n100k\n        const row = n100kLetters[(this.zone-1)%2].indexOf(this.n100k);\n        const n100kNum = row * 100e3; // n100k in metres\n\n        // get latitude of (bottom of) band\n        const latBand = (latBands.indexOf(this.band)-10)*8;\n\n        // get northing of bottom of band, extended to include entirety of bottom-most 100km square\n        const nBand = Math.floor(new LatLonEllipsoidal(latBand, 3).toUtm().northing/100e3)*100e3;\n\n        // 100km grid square row letters repeat every 2,000km north; add enough 2,000km blocks to\n        // get into required band\n        let n2M = 0; // northing of 2,000km block\n        while (n2M + n100kNum + this.northing < nBand) n2M += 2000e3;\n\n        return new Utm_Mgrs(this.zone, hemisphere, e100kNum+this.easting, n2M+n100kNum+this.northing, this.datum);\n    }\n\n\n    /**\n     * Parses string representation of MGRS grid reference.\n     *\n     * An MGRS grid reference comprises (space-separated)\n     *  - grid zone designator (GZD)\n     *  - 100km grid square letter-pair\n     *  - easting\n     *  - northing.\n     *\n     * @param   {string} mgrsGridRef - String representation of MGRS grid reference.\n     * @returns {Mgrs}   Mgrs grid reference object.\n     * @throws  {Error}  Invalid MGRS grid reference.\n     *\n     * @example\n     *   const mgrsRef = Mgrs.parse('31U DQ 48251 11932');\n     *   const mgrsRef = Mgrs.parse('31UDQ4825111932');\n     *   //  mgrsRef: { zone:31, band:'U', e100k:'D', n100k:'Q', easting:48251, northing:11932 }\n     */\n    static parse(mgrsGridRef) {\n        if (!mgrsGridRef) throw new Error(`invalid MGRS grid reference ‘${mgrsGridRef}’`);\n\n        // check for military-style grid reference with no separators\n        if (!mgrsGridRef.trim().match(/\\s/)) {\n            if (!Number(mgrsGridRef.slice(0, 2))) throw new Error(`invalid MGRS grid reference ‘${mgrsGridRef}’`);\n            let en = mgrsGridRef.trim().slice(5); // get easting/northing following zone/band/100ksq\n            en = en.slice(0, en.length/2)+' '+en.slice(-en.length/2); // separate easting/northing\n            mgrsGridRef = mgrsGridRef.slice(0, 3)+' '+mgrsGridRef.slice(3, 5)+' '+en; // insert spaces\n        }\n\n        // match separate elements (separated by whitespace)\n        const ref = mgrsGridRef.match(/\\S+/g);\n\n        if (ref==null || ref.length!=4) throw new Error(`invalid MGRS grid reference ‘${mgrsGridRef}’`);\n\n        // split gzd into zone/band\n        const gzd = ref[0];\n        const zone = gzd.slice(0, 2);\n        const band = gzd.slice(2, 3);\n\n        // split 100km letter-pair into e/n\n        const en100k = ref[1];\n        const e100k = en100k.slice(0, 1);\n        const n100k = en100k.slice(1, 2);\n\n        let e = ref[2], n = ref[3];\n\n        // standardise to 10-digit refs - ie metres) (but only if < 10-digit refs, to allow decimals)\n        e = e.length>=5 ?  e : (e+'00000').slice(0, 5);\n        n = n.length>=5 ?  n : (n+'00000').slice(0, 5);\n\n        return new Mgrs(zone, band, e100k, n100k, e, n);\n    }\n\n\n    /**\n     * Returns a string representation of an MGRS grid reference.\n     *\n     * To distinguish from civilian UTM coordinate representations, no space is included within the\n     * zone/band grid zone designator.\n     *\n     * Components are separated by spaces: for a military-style unseparated string, use\n     *   Mgrs.toString().replace(/ /g, '');\n     *\n     * Note that MGRS grid references get truncated, not rounded (unlike UTM coordinates); grid\n     * references indicate a bounding square, rather than a point, with the size of the square\n     * indicated by the precision - a precision of 10 indicates a 1-metre square, a precision of 4\n     * indicates a 1,000-metre square (hence 31U DQ 48 11 indicates a 1km square with SW corner at\n     * 31 N 448000 5411000, which would include the 1m square 31U DQ 48251 11932).\n     *\n     * @param   {number}     [digits=10] - Precision of returned grid reference (eg 4 = km, 10 = m).\n     * @returns {string}     This grid reference in standard format.\n     * @throws  {RangeError} Invalid precision.\n     *\n     * @example\n     *   const mgrsStr = new Mgrs(31, 'U', 'D', 'Q', 48251, 11932).toString(); // 31U DQ 48251 11932\n     */\n    toString(digits=10) {\n        if (![ 2, 4, 6, 8, 10 ].includes(Number(digits))) throw new RangeError(`invalid precision ‘${digits}’`);\n\n        const { zone, band, e100k, n100k, easting, northing } = this;\n\n        // truncate to required precision\n        const eRounded = Math.floor(easting/Math.pow(10, 5-digits/2));\n        const nRounded = Math.floor(northing/Math.pow(10, 5-digits/2));\n\n        // ensure leading zeros\n        const zPadded = zone.toString().padStart(2, '0');\n        const ePadded = eRounded.toString().padStart(digits/2, '0');\n        const nPadded = nRounded.toString().padStart(digits/2, '0');\n\n        return `${zPadded}${band} ${e100k}${n100k} ${ePadded} ${nPadded}`;\n    }\n}\n\n\n/* Utm_Mgrs - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n\n/**\n * Extends Utm with method to convert UTM coordinate to MGRS reference.\n *\n * @extends Utm\n */\nclass Utm_Mgrs extends Utm {\n\n    /**\n     * Converts UTM coordinate to MGRS reference.\n     *\n     * @returns {Mgrs}\n     * @throws  {TypeError} Invalid UTM coordinate.\n     *\n     * @example\n     *   const utmCoord = new Utm(31, 'N', 448251, 5411932);\n     *   const mgrsRef = utmCoord.toMgrs(); // 31U DQ 48251 11932\n     */\n    toMgrs() {\n        // MGRS zone is same as UTM zone\n        const zone = this.zone;\n\n        // convert UTM to lat/long to get latitude to determine band\n        const latlong = this.toLatLon();\n        // grid zones are 8° tall, 0°N is 10th band\n        const band = latBands.charAt(Math.floor(latlong.lat/8+10)); // latitude band\n\n        // columns in zone 1 are A-H, zone 2 J-R, zone 3 S-Z, then repeating every 3rd zone\n        const col = Math.floor(this.easting / 100e3);\n        // (note -1 because eastings start at 166e3 due to 500km false origin)\n        const e100k = e100kLetters[(zone-1)%3].charAt(col-1);\n\n        // rows in even zones are A-V, in odd zones are F-E\n        const row = Math.floor(this.northing / 100e3) % 20;\n        const n100k = n100kLetters[(zone-1)%2].charAt(row);\n\n        // truncate easting/northing to within 100km grid square\n        let easting = this.easting % 100e3;\n        let northing = this.northing % 100e3;\n\n        // round to nm precision\n        easting = Number(easting.toFixed(6));\n        northing = Number(northing.toFixed(6));\n\n        return new Mgrs(zone, band, e100k, n100k, easting, northing);\n    }\n\n}\n\n\n/**\n * Extends LatLonEllipsoidal adding toMgrs() method to the Utm object returned by LatLon.toUtm().\n *\n * @extends LatLonEllipsoidal\n */\nclass Latlon_Utm_Mgrs extends LatLonEllipsoidal {\n\n    /**\n     * Converts latitude/longitude to UTM coordinate.\n     *\n     * Shadow of LatLon.toUtm, returning Utm augmented with toMgrs() method.\n     *\n     * @param   {number} [zoneOverride] - Use specified zone rather than zone within which point lies;\n     *          note overriding the UTM zone has the potential to result in negative eastings, and\n     *          perverse results within Norway/Svalbard exceptions (this is unlikely to be relevant\n     *          for MGRS, but is needed as Mgrs passes through the Utm class).\n     * @returns {Utm}   UTM coordinate.\n     * @throws  {Error} If point not valid, if point outside latitude range.\n     *\n     * @example\n     *   const latlong = new LatLon(48.8582, 2.2945);\n     *   const utmCoord = latlong.toUtm(); // 31 N 448252 5411933\n     */\n    toUtm(zoneOverride=undefined) {\n        const utm = super.toUtm(zoneOverride);\n        return new Utm_Mgrs(utm.zone, utm.hemisphere, utm.easting, utm.northing, utm.datum, utm.convergence, utm.scale);\n    }\n\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nexport { Mgrs as default, Utm_Mgrs as Utm, Latlon_Utm_Mgrs as LatLon, Dms };\n"],
  "mappings": "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",
  "names": []
}
