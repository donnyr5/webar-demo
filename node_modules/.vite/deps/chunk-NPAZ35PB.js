import {
  dms_default
} from "./chunk-GIFWOSH2.js";

// node_modules/geodesy/vector3d.js
var Vector3d = class _Vector3d {
  /**
   * Creates a 3-d vector.
   *
   * @param {number} x - X component of vector.
   * @param {number} y - Y component of vector.
   * @param {number} z - Z component of vector.
   *
   * @example
   *   import Vector3d from '/js/geodesy/vector3d.js';
   *   const v = new Vector3d(0.267, 0.535, 0.802);
   */
  constructor(x, y, z) {
    if (isNaN(x) || isNaN(y) || isNaN(z))
      throw new TypeError(`invalid vector [${x},${y},${z}]`);
    this.x = Number(x);
    this.y = Number(y);
    this.z = Number(z);
  }
  /**
   * Length (magnitude or norm) of ‘this’ vector.
   *
   * @returns {number} Magnitude of this vector.
   */
  get length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  /**
   * Adds supplied vector to ‘this’ vector.
   *
   * @param   {Vector3d} v - Vector to be added to this vector.
   * @returns {Vector3d} Vector representing sum of this and v.
   */
  plus(v) {
    if (!(v instanceof _Vector3d))
      throw new TypeError("v is not Vector3d object");
    return new _Vector3d(this.x + v.x, this.y + v.y, this.z + v.z);
  }
  /**
   * Subtracts supplied vector from ‘this’ vector.
   *
   * @param   {Vector3d} v - Vector to be subtracted from this vector.
   * @returns {Vector3d} Vector representing difference between this and v.
   */
  minus(v) {
    if (!(v instanceof _Vector3d))
      throw new TypeError("v is not Vector3d object");
    return new _Vector3d(this.x - v.x, this.y - v.y, this.z - v.z);
  }
  /**
   * Multiplies ‘this’ vector by a scalar value.
   *
   * @param   {number}   x - Factor to multiply this vector by.
   * @returns {Vector3d} Vector scaled by x.
   */
  times(x) {
    if (isNaN(x))
      throw new TypeError(`invalid scalar value ‘${x}’`);
    return new _Vector3d(this.x * x, this.y * x, this.z * x);
  }
  /**
   * Divides ‘this’ vector by a scalar value.
   *
   * @param   {number}   x - Factor to divide this vector by.
   * @returns {Vector3d} Vector divided by x.
   */
  dividedBy(x) {
    if (isNaN(x))
      throw new TypeError(`invalid scalar value ‘${x}’`);
    return new _Vector3d(this.x / x, this.y / x, this.z / x);
  }
  /**
   * Multiplies ‘this’ vector by the supplied vector using dot (scalar) product.
   *
   * @param   {Vector3d} v - Vector to be dotted with this vector.
   * @returns {number}   Dot product of ‘this’ and v.
   */
  dot(v) {
    if (!(v instanceof _Vector3d))
      throw new TypeError("v is not Vector3d object");
    return this.x * v.x + this.y * v.y + this.z * v.z;
  }
  /**
   * Multiplies ‘this’ vector by the supplied vector using cross (vector) product.
   *
   * @param   {Vector3d} v - Vector to be crossed with this vector.
   * @returns {Vector3d} Cross product of ‘this’ and v.
   */
  cross(v) {
    if (!(v instanceof _Vector3d))
      throw new TypeError("v is not Vector3d object");
    const x = this.y * v.z - this.z * v.y;
    const y = this.z * v.x - this.x * v.z;
    const z = this.x * v.y - this.y * v.x;
    return new _Vector3d(x, y, z);
  }
  /**
   * Negates a vector to point in the opposite direction.
   *
   * @returns {Vector3d} Negated vector.
   */
  negate() {
    return new _Vector3d(-this.x, -this.y, -this.z);
  }
  /**
   * Normalizes a vector to its unit vector
   * – if the vector is already unit or is zero magnitude, this is a no-op.
   *
   * @returns {Vector3d} Normalised version of this vector.
   */
  unit() {
    const norm = this.length;
    if (norm == 1)
      return this;
    if (norm == 0)
      return this;
    const x = this.x / norm;
    const y = this.y / norm;
    const z = this.z / norm;
    return new _Vector3d(x, y, z);
  }
  /**
   * Calculates the angle between ‘this’ vector and supplied vector atan2(|p₁×p₂|, p₁·p₂) (or if
   * (extra-planar) ‘n’ supplied then atan2(n·p₁×p₂, p₁·p₂).
   *
   * @param   {Vector3d} v - Vector whose angle is to be determined from ‘this’ vector.
   * @param   {Vector3d} [n] - Plane normal: if supplied, angle is signed +ve if this->v is
   *                     clockwise looking along n, -ve in opposite direction.
   * @returns {number}   Angle (in radians) between this vector and supplied vector (in range 0..π
   *                     if n not supplied, range -π..+π if n supplied).
   */
  angleTo(v, n = void 0) {
    if (!(v instanceof _Vector3d))
      throw new TypeError("v is not Vector3d object");
    if (!(n instanceof _Vector3d || n == void 0))
      throw new TypeError("n is not Vector3d object");
    const sign = n == void 0 || this.cross(v).dot(n) >= 0 ? 1 : -1;
    const sinθ = this.cross(v).length * sign;
    const cosθ = this.dot(v);
    return Math.atan2(sinθ, cosθ);
  }
  /**
   * Rotates ‘this’ point around an axis by a specified angle.
   *
   * @param   {Vector3d} axis - The axis being rotated around.
   * @param   {number}   angle - The angle of rotation (in degrees).
   * @returns {Vector3d} The rotated point.
   */
  rotateAround(axis, angle) {
    if (!(axis instanceof _Vector3d))
      throw new TypeError("axis is not Vector3d object");
    const θ = angle.toRadians();
    const p = this.unit();
    const a = axis.unit();
    const s = Math.sin(θ);
    const c = Math.cos(θ);
    const t = 1 - c;
    const x = a.x, y = a.y, z = a.z;
    const r = [
      // rotation matrix for rotation about supplied axis
      [t * x * x + c, t * x * y - s * z, t * x * z + s * y],
      [t * x * y + s * z, t * y * y + c, t * y * z - s * x],
      [t * x * z - s * y, t * y * z + s * x, t * z * z + c]
    ];
    const rp = [
      r[0][0] * p.x + r[0][1] * p.y + r[0][2] * p.z,
      r[1][0] * p.x + r[1][1] * p.y + r[1][2] * p.z,
      r[2][0] * p.x + r[2][1] * p.y + r[2][2] * p.z
    ];
    const p2 = new _Vector3d(rp[0], rp[1], rp[2]);
    return p2;
  }
  /**
   * String representation of vector.
   *
   * @param   {number} [dp=3] - Number of decimal places to be used.
   * @returns {string} Vector represented as [x,y,z].
   */
  toString(dp = 3) {
    return `[${this.x.toFixed(dp)},${this.y.toFixed(dp)},${this.z.toFixed(dp)}]`;
  }
};
Number.prototype.toRadians = function() {
  return this * Math.PI / 180;
};
Number.prototype.toDegrees = function() {
  return this * 180 / Math.PI;
};
var vector3d_default = Vector3d;

// node_modules/geodesy/latlon-ellipsoidal.js
var ellipsoids = {
  WGS84: { a: 6378137, b: 6356752314245e-6, f: 1 / 298.257223563 }
};
var datums = {
  WGS84: { ellipsoid: ellipsoids.WGS84 }
};
Object.freeze(ellipsoids.WGS84);
Object.freeze(datums.WGS84);
var LatLonEllipsoidal = class _LatLonEllipsoidal {
  /**
   * Creates a geodetic latitude/longitude point on a (WGS84) ellipsoidal model earth.
   *
   * @param  {number} lat - Latitude (in degrees).
   * @param  {number} lon - Longitude (in degrees).
   * @param  {number} [height=0] - Height above ellipsoid in metres.
   * @throws {TypeError} Invalid lat/lon/height.
   *
   * @example
   *   import LatLon from '/js/geodesy/latlon-ellipsoidal.js';
   *   const p = new LatLon(51.47788, -0.00147, 17);
   */
  constructor(lat, lon, height = 0) {
    if (isNaN(lat) || lat == null)
      throw new TypeError(`invalid lat ‘${lat}’`);
    if (isNaN(lon) || lon == null)
      throw new TypeError(`invalid lon ‘${lon}’`);
    if (isNaN(height) || height == null)
      throw new TypeError(`invalid height ‘${height}’`);
    this._lat = dms_default.wrap90(Number(lat));
    this._lon = dms_default.wrap180(Number(lon));
    this._height = Number(height);
  }
  /**
   * Latitude in degrees north from equator (including aliases lat, latitude): can be set as
   * numeric or hexagesimal (deg-min-sec); returned as numeric.
   */
  get lat() {
    return this._lat;
  }
  get latitude() {
    return this._lat;
  }
  set lat(lat) {
    this._lat = isNaN(lat) ? dms_default.wrap90(dms_default.parse(lat)) : dms_default.wrap90(Number(lat));
    if (isNaN(this._lat))
      throw new TypeError(`invalid lat ‘${lat}’`);
  }
  set latitude(lat) {
    this._lat = isNaN(lat) ? dms_default.wrap90(dms_default.parse(lat)) : dms_default.wrap90(Number(lat));
    if (isNaN(this._lat))
      throw new TypeError(`invalid latitude ‘${lat}’`);
  }
  /**
   * Longitude in degrees east from international reference meridian (including aliases lon, lng,
   * longitude): can be set as numeric or hexagesimal (deg-min-sec); returned as numeric.
   */
  get lon() {
    return this._lon;
  }
  get lng() {
    return this._lon;
  }
  get longitude() {
    return this._lon;
  }
  set lon(lon) {
    this._lon = isNaN(lon) ? dms_default.wrap180(dms_default.parse(lon)) : dms_default.wrap180(Number(lon));
    if (isNaN(this._lon))
      throw new TypeError(`invalid lon ‘${lon}’`);
  }
  set lng(lon) {
    this._lon = isNaN(lon) ? dms_default.wrap180(dms_default.parse(lon)) : dms_default.wrap180(Number(lon));
    if (isNaN(this._lon))
      throw new TypeError(`invalid lng ‘${lon}’`);
  }
  set longitude(lon) {
    this._lon = isNaN(lon) ? dms_default.wrap180(dms_default.parse(lon)) : dms_default.wrap180(Number(lon));
    if (isNaN(this._lon))
      throw new TypeError(`invalid longitude ‘${lon}’`);
  }
  /**
   * Height in metres above ellipsoid.
   */
  get height() {
    return this._height;
  }
  set height(height) {
    this._height = Number(height);
    if (isNaN(this._height))
      throw new TypeError(`invalid height ‘${height}’`);
  }
  /**
   * Datum.
   *
   * Note this is replicated within LatLonEllipsoidal in order that a LatLonEllipsoidal object can
   * be monkey-patched to look like a LatLonEllipsoidal_Datum, for Vincenty calculations on
   * different ellipsoids.
   *
   * @private
   */
  get datum() {
    return this._datum;
  }
  set datum(datum) {
    this._datum = datum;
  }
  /**
   * Ellipsoids with their parameters; this module only defines WGS84 parameters a = 6378137, b =
   * 6356752.314245, f = 1/298.257223563.
   *
   * @example
   *   const a = LatLon.ellipsoids.WGS84.a; // 6378137
   */
  static get ellipsoids() {
    return ellipsoids;
  }
  /**
   * Datums; this module only defines WGS84 datum, hence no datum transformations.
   *
   * @example
   *   const a = LatLon.datums.WGS84.ellipsoid.a; // 6377563.396
   */
  static get datums() {
    return datums;
  }
  /**
   * Parses a latitude/longitude point from a variety of formats.
   *
   * Latitude & longitude (in degrees) can be supplied as two separate parameters, as a single
   * comma-separated lat/lon string, or as a single object with { lat, lon } or GeoJSON properties.
   *
   * The latitude/longitude values may be numeric or strings; they may be signed decimal or
   * deg-min-sec (hexagesimal) suffixed by compass direction (NSEW); a variety of separators are
   * accepted. Examples -3.62, '3 37 12W', '3°37′12″W'.
   *
   * Thousands/decimal separators must be comma/dot; use Dms.fromLocale to convert locale-specific
   * thousands/decimal separators.
   *
   * @param   {number|string|Object} lat|latlon - Latitude (in degrees), or comma-separated lat/lon, or lat/lon object.
   * @param   {number}               [lon]      - Longitude (in degrees).
   * @param   {number}               [height=0] - Height above ellipsoid in metres.
   * @returns {LatLon} Latitude/longitude point on WGS84 ellipsoidal model earth.
   * @throws  {TypeError} Invalid coordinate.
   *
   * @example
   *   const p1 = LatLon.parse(51.47788, -0.00147);              // numeric pair
   *   const p2 = LatLon.parse('51°28′40″N, 000°00′05″W', 17);   // dms string + height
   *   const p3 = LatLon.parse({ lat: 52.205, lon: 0.119 }, 17); // { lat, lon } object numeric + height
   */
  static parse(...args) {
    if (args.length == 0)
      throw new TypeError("invalid (empty) point");
    let lat = void 0, lon = void 0, height = void 0;
    if (typeof args[0] == "object" && (args.length == 1 || !isNaN(parseFloat(args[1])))) {
      const ll = args[0];
      if (ll.type == "Point" && Array.isArray(ll.coordinates)) {
        [lon, lat, height] = ll.coordinates;
        height = height || 0;
      } else {
        if (ll.latitude != void 0)
          lat = ll.latitude;
        if (ll.lat != void 0)
          lat = ll.lat;
        if (ll.longitude != void 0)
          lon = ll.longitude;
        if (ll.lng != void 0)
          lon = ll.lng;
        if (ll.lon != void 0)
          lon = ll.lon;
        if (ll.height != void 0)
          height = ll.height;
        lat = dms_default.wrap90(dms_default.parse(lat));
        lon = dms_default.wrap180(dms_default.parse(lon));
      }
      if (args[1] != void 0)
        height = args[1];
      if (isNaN(lat) || isNaN(lon))
        throw new TypeError(`invalid point ‘${JSON.stringify(args[0])}’`);
    }
    if (typeof args[0] == "string" && args[0].split(",").length == 2) {
      [lat, lon] = args[0].split(",");
      lat = dms_default.wrap90(dms_default.parse(lat));
      lon = dms_default.wrap180(dms_default.parse(lon));
      height = args[1] || 0;
      if (isNaN(lat) || isNaN(lon))
        throw new TypeError(`invalid point ‘${args[0]}’`);
    }
    if (lat == void 0 && lon == void 0) {
      [lat, lon] = args;
      lat = dms_default.wrap90(dms_default.parse(lat));
      lon = dms_default.wrap180(dms_default.parse(lon));
      height = args[2] || 0;
      if (isNaN(lat) || isNaN(lon))
        throw new TypeError(`invalid point ‘${args.toString()}’`);
    }
    return new this(lat, lon, height);
  }
  /**
   * Converts ‘this’ point from (geodetic) latitude/longitude coordinates to (geocentric)
   * cartesian (x/y/z) coordinates.
   *
   * @returns {Cartesian} Cartesian point equivalent to lat/lon point, with x, y, z in metres from
   *   earth centre.
   */
  toCartesian() {
    const ellipsoid = this.datum ? this.datum.ellipsoid : this.referenceFrame ? this.referenceFrame.ellipsoid : ellipsoids.WGS84;
    const φ = this.lat.toRadians();
    const λ = this.lon.toRadians();
    const h = this.height;
    const { a, f } = ellipsoid;
    const sinφ = Math.sin(φ), cosφ = Math.cos(φ);
    const sinλ = Math.sin(λ), cosλ = Math.cos(λ);
    const eSq = 2 * f - f * f;
    const ν = a / Math.sqrt(1 - eSq * sinφ * sinφ);
    const x = (ν + h) * cosφ * cosλ;
    const y = (ν + h) * cosφ * sinλ;
    const z = (ν * (1 - eSq) + h) * sinφ;
    return new Cartesian(x, y, z);
  }
  /**
   * Checks if another point is equal to ‘this’ point.
   *
   * @param   {LatLon} point - Point to be compared against this point.
   * @returns {bool} True if points have identical latitude, longitude, height, and datum/referenceFrame.
   * @throws  {TypeError} Invalid point.
   *
   * @example
   *   const p1 = new LatLon(52.205, 0.119);
   *   const p2 = new LatLon(52.205, 0.119);
   *   const equal = p1.equals(p2); // true
   */
  equals(point) {
    if (!(point instanceof _LatLonEllipsoidal))
      throw new TypeError(`invalid point ‘${point}’`);
    if (Math.abs(this.lat - point.lat) > Number.EPSILON)
      return false;
    if (Math.abs(this.lon - point.lon) > Number.EPSILON)
      return false;
    if (Math.abs(this.height - point.height) > Number.EPSILON)
      return false;
    if (this.datum != point.datum)
      return false;
    if (this.referenceFrame != point.referenceFrame)
      return false;
    if (this.epoch != point.epoch)
      return false;
    return true;
  }
  /**
   * Returns a string representation of ‘this’ point, formatted as degrees, degrees+minutes, or
   * degrees+minutes+seconds.
   *
   * @param   {string} [format=d] - Format point as 'd', 'dm', 'dms', or 'n' for signed numeric.
   * @param   {number} [dp=4|2|0] - Number of decimal places to use: default 4 for d, 2 for dm, 0 for dms.
   * @param   {number} [dpHeight=null] - Number of decimal places to use for height; default is no height display.
   * @returns {string} Comma-separated formatted latitude/longitude.
   * @throws  {RangeError} Invalid format.
   *
   * @example
   *   const greenwich = new LatLon(51.47788, -0.00147, 46);
   *   const d = greenwich.toString();                        // 51.4779°N, 000.0015°W
   *   const dms = greenwich.toString('dms', 2);              // 51°28′40″N, 000°00′05″W
   *   const [lat, lon] = greenwich.toString('n').split(','); // 51.4779, -0.0015
   *   const dmsh = greenwich.toString('dms', 0, 0);          // 51°28′40″N, 000°00′06″W +46m
   */
  toString(format = "d", dp = void 0, dpHeight = null) {
    if (!["d", "dm", "dms", "n"].includes(format))
      throw new RangeError(`invalid format ‘${format}’`);
    const height = (this.height >= 0 ? " +" : " ") + this.height.toFixed(dpHeight) + "m";
    if (format == "n") {
      if (dp == void 0)
        dp = 4;
      const lat2 = this.lat.toFixed(dp);
      const lon2 = this.lon.toFixed(dp);
      return `${lat2}, ${lon2}${dpHeight == null ? "" : height}`;
    }
    const lat = dms_default.toLat(this.lat, format, dp);
    const lon = dms_default.toLon(this.lon, format, dp);
    return `${lat}, ${lon}${dpHeight == null ? "" : height}`;
  }
};
var Cartesian = class extends vector3d_default {
  /**
   * Creates cartesian coordinate representing ECEF (earth-centric earth-fixed) point.
   *
   * @param {number} x - X coordinate in metres (=> 0°N,0°E).
   * @param {number} y - Y coordinate in metres (=> 0°N,90°E).
   * @param {number} z - Z coordinate in metres (=> 90°N).
   *
   * @example
   *   import { Cartesian } from '/js/geodesy/latlon-ellipsoidal.js';
   *   const coord = new Cartesian(3980581.210, -111.159, 4966824.522);
   */
  constructor(x, y, z) {
    super(x, y, z);
  }
  /**
   * Converts ‘this’ (geocentric) cartesian (x/y/z) coordinate to (geodetic) latitude/longitude
   * point on specified ellipsoid.
   *
   * Uses Bowring’s (1985) formulation for μm precision in concise form; ‘The accuracy of geodetic
   * latitude and height equations’, B R Bowring, Survey Review vol 28, 218, Oct 1985.
   *
   * @param   {LatLon.ellipsoids} [ellipsoid=WGS84] - Ellipsoid to use when converting point.
   * @returns {LatLon} Latitude/longitude point defined by cartesian coordinates, on given ellipsoid.
   * @throws  {TypeError} Invalid ellipsoid.
   *
   * @example
   *   const c = new Cartesian(4027893.924, 307041.993, 4919474.294);
   *   const p = c.toLatLon(); // 50.7978°N, 004.3592°E
   */
  toLatLon(ellipsoid = ellipsoids.WGS84) {
    if (!ellipsoid || !ellipsoid.a)
      throw new TypeError(`invalid ellipsoid ‘${ellipsoid}’`);
    const { x, y, z } = this;
    const { a, b, f } = ellipsoid;
    const e2 = 2 * f - f * f;
    const ε2 = e2 / (1 - e2);
    const p = Math.sqrt(x * x + y * y);
    const R = Math.sqrt(p * p + z * z);
    const tanβ = b * z / (a * p) * (1 + ε2 * b / R);
    const sinβ = tanβ / Math.sqrt(1 + tanβ * tanβ);
    const cosβ = sinβ / tanβ;
    const φ = isNaN(cosβ) ? 0 : Math.atan2(z + ε2 * b * sinβ * sinβ * sinβ, p - e2 * a * cosβ * cosβ * cosβ);
    const λ = Math.atan2(y, x);
    const sinφ = Math.sin(φ), cosφ = Math.cos(φ);
    const ν = a / Math.sqrt(1 - e2 * sinφ * sinφ);
    const h = p * cosφ + z * sinφ - a * a / ν;
    const point = new LatLonEllipsoidal(φ.toDegrees(), λ.toDegrees(), h);
    return point;
  }
  /**
   * Returns a string representation of ‘this’ cartesian point.
   *
   * @param   {number} [dp=0] - Number of decimal places to use.
   * @returns {string} Comma-separated latitude/longitude.
   */
  toString(dp = 0) {
    const x = this.x.toFixed(dp), y = this.y.toFixed(dp), z = this.z.toFixed(dp);
    return `[${x},${y},${z}]`;
  }
};

// node_modules/geodesy/latlon-ellipsoidal-datum.js
var ellipsoids2 = {
  WGS84: { a: 6378137, b: 6356752314245e-6, f: 1 / 298.257223563 },
  Airy1830: { a: 6377563396e-3, b: 6356256909e-3, f: 1 / 299.3249646 },
  AiryModified: { a: 6377340189e-3, b: 6356034448e-3, f: 1 / 299.3249646 },
  Bessel1841: { a: 6377397155e-3, b: 6356078962818e-6, f: 1 / 299.1528128 },
  Clarke1866: { a: 63782064e-1, b: 63565838e-1, f: 1 / 294.978698214 },
  Clarke1880IGN: { a: 63782492e-1, b: 6356515, f: 1 / 293.466021294 },
  GRS80: { a: 6378137, b: 635675231414e-5, f: 1 / 298.257222101 },
  Intl1924: { a: 6378388, b: 6356911946e-3, f: 1 / 297 },
  // aka Hayford
  WGS72: { a: 6378135, b: 63567505e-1, f: 1 / 298.26 }
};
var datums2 = {
  // transforms: t in metres, s in ppm, r in arcseconds              tx       ty        tz       s        rx        ry        rz
  ED50: { ellipsoid: ellipsoids2.Intl1924, transform: [89.5, 93.8, 123.1, -1.2, 0, 0, 0.156] },
  // epsg.io/1311
  ETRS89: { ellipsoid: ellipsoids2.GRS80, transform: [0, 0, 0, 0, 0, 0, 0] },
  // epsg.io/1149; @ 1-metre level
  Irl1975: { ellipsoid: ellipsoids2.AiryModified, transform: [-482.53, 130.596, -564.557, -8.15, 1.042, 0.214, 0.631] },
  // epsg.io/1954
  NAD27: { ellipsoid: ellipsoids2.Clarke1866, transform: [8, -160, -176, 0, 0, 0, 0] },
  NAD83: { ellipsoid: ellipsoids2.GRS80, transform: [0.9956, -1.9103, -0.5215, -62e-5, 0.025915, 9426e-6, 0.011599] },
  NTF: { ellipsoid: ellipsoids2.Clarke1880IGN, transform: [168, 60, -320, 0, 0, 0, 0] },
  OSGB36: { ellipsoid: ellipsoids2.Airy1830, transform: [-446.448, 125.157, -542.06, 20.4894, -0.1502, -0.247, -0.8421] },
  // epsg.io/1314
  Potsdam: { ellipsoid: ellipsoids2.Bessel1841, transform: [-582, -105, -414, -8.3, 1.04, 0.35, -3.08] },
  TokyoJapan: { ellipsoid: ellipsoids2.Bessel1841, transform: [148, -507, -685, 0, 0, 0, 0] },
  WGS72: { ellipsoid: ellipsoids2.WGS72, transform: [0, 0, -4.5, -0.22, 0, 0, 0.554] },
  WGS84: { ellipsoid: ellipsoids2.WGS84, transform: [0, 0, 0, 0, 0, 0, 0] }
};
Object.keys(ellipsoids2).forEach((e) => Object.freeze(ellipsoids2[e]));
Object.keys(datums2).forEach((d) => {
  Object.freeze(datums2[d]);
  Object.freeze(datums2[d].transform);
});
var LatLonEllipsoidal_Datum = class extends LatLonEllipsoidal {
  /**
   * Creates a geodetic latitude/longitude point on an ellipsoidal model earth using given datum.
   *
   * @param {number} lat - Latitude (in degrees).
   * @param {number} lon - Longitude (in degrees).
   * @param {number} [height=0] - Height above ellipsoid in metres.
   * @param {LatLon.datums} datum - Datum this point is defined within.
   *
   * @example
   *   import LatLon from '/js/geodesy/latlon-ellipsoidal-datum.js';
   *   const p = new LatLon(53.3444, -6.2577, 17, LatLon.datums.Irl1975);
   */
  constructor(lat, lon, height = 0, datum = datums2.WGS84) {
    if (!datum || datum.ellipsoid == void 0)
      throw new TypeError(`unrecognised datum ‘${datum}’`);
    super(lat, lon, height);
    this._datum = datum;
  }
  /**
   * Datum this point is defined within.
   */
  get datum() {
    return this._datum;
  }
  /**
   * Ellipsoids with their parameters; semi-major axis (a), semi-minor axis (b), and flattening (f).
   *
   * Flattening f = (a−b)/a; at least one of these parameters is derived from defining constants.
   *
   * @example
   *   const a = LatLon.ellipsoids.Airy1830.a; // 6377563.396
   */
  static get ellipsoids() {
    return ellipsoids2;
  }
  /**
   * Datums; with associated ellipsoid, and Helmert transform parameters to convert from WGS-84
   * into given datum.
   *
   * Note that precision of various datums will vary, and WGS-84 (original) is not defined to be
   * accurate to better than ±1 metre. No transformation should be assumed to be accurate to
   * better than a metre, for many datums somewhat less.
   *
   * This is a small sample of commoner datums from a large set of historical datums. I will add
   * new datums on request.
   *
   * @example
   *   const a = LatLon.datums.OSGB36.ellipsoid.a;                    // 6377563.396
   *   const tx = LatLon.datums.OSGB36.transform;                     // [ tx, ty, tz, s, rx, ry, rz ]
   *   const availableDatums = Object.keys(LatLon.datums).join(', '); // ED50, Irl1975, NAD27, ...
   */
  static get datums() {
    return datums2;
  }
  // note instance datum getter/setters are in LatLonEllipsoidal
  /**
   * Parses a latitude/longitude point from a variety of formats.
   *
   * Latitude & longitude (in degrees) can be supplied as two separate parameters, as a single
   * comma-separated lat/lon string, or as a single object with { lat, lon } or GeoJSON properties.
   *
   * The latitude/longitude values may be numeric or strings; they may be signed decimal or
   * deg-min-sec (hexagesimal) suffixed by compass direction (NSEW); a variety of separators are
   * accepted. Examples -3.62, '3 37 12W', '3°37′12″W'.
   *
   * Thousands/decimal separators must be comma/dot; use Dms.fromLocale to convert locale-specific
   * thousands/decimal separators.
   *
   * @param   {number|string|Object} lat|latlon - Geodetic Latitude (in degrees) or comma-separated lat/lon or lat/lon object.
   * @param   {number}               [lon] - Longitude in degrees.
   * @param   {number}               [height=0] - Height above ellipsoid in metres.
   * @param   {LatLon.datums}        [datum=WGS84] - Datum this point is defined within.
   * @returns {LatLon} Latitude/longitude point on ellipsoidal model earth using given datum.
   * @throws  {TypeError} Unrecognised datum.
   *
   * @example
   *   const p = LatLon.parse('51.47736, 0.0000', 0, LatLon.datums.OSGB36);
   */
  static parse(...args) {
    let datum = datums2.WGS84;
    if (args.length == 4 || args.length == 3 && typeof args[2] == "object")
      datum = args.pop();
    if (!datum || datum.ellipsoid == void 0)
      throw new TypeError(`unrecognised datum ‘${datum}’`);
    const point = super.parse(...args);
    point._datum = datum;
    return point;
  }
  /**
   * Converts ‘this’ lat/lon coordinate to new coordinate system.
   *
   * @param   {LatLon.datums} toDatum - Datum this coordinate is to be converted to.
   * @returns {LatLon} This point converted to new datum.
   * @throws  {TypeError} Unrecognised datum.
   *
   * @example
   *   const pWGS84 = new LatLon(51.47788, -0.00147, 0, LatLon.datums.WGS84);
   *   const pOSGB = pWGS84.convertDatum(LatLon.datums.OSGB36); // 51.4773°N, 000.0001°E
   */
  convertDatum(toDatum) {
    if (!toDatum || toDatum.ellipsoid == void 0)
      throw new TypeError(`unrecognised datum ‘${toDatum}’`);
    const oldCartesian = this.toCartesian();
    const newCartesian = oldCartesian.convertDatum(toDatum);
    const newLatLon = newCartesian.toLatLon();
    return newLatLon;
  }
  /**
   * Converts ‘this’ point from (geodetic) latitude/longitude coordinates to (geocentric) cartesian
   * (x/y/z) coordinates, based on the same datum.
   *
   * Shadow of LatLonEllipsoidal.toCartesian(), returning Cartesian augmented with
   * LatLonEllipsoidal_Datum methods/properties.
   *
   * @returns {Cartesian} Cartesian point equivalent to lat/lon point, with x, y, z in metres from
   *   earth centre, augmented with reference frame conversion methods and properties.
   */
  toCartesian() {
    const cartesian = super.toCartesian();
    const cartesianDatum = new Cartesian_Datum(cartesian.x, cartesian.y, cartesian.z, this.datum);
    return cartesianDatum;
  }
};
var Cartesian_Datum = class _Cartesian_Datum extends Cartesian {
  /**
   * Creates cartesian coordinate representing ECEF (earth-centric earth-fixed) point, on a given
   * datum. The datum will identify the primary meridian (for the x-coordinate), and is also
   * useful in transforming to/from geodetic (lat/lon) coordinates.
   *
   * @param  {number} x - X coordinate in metres (=> 0°N,0°E).
   * @param  {number} y - Y coordinate in metres (=> 0°N,90°E).
   * @param  {number} z - Z coordinate in metres (=> 90°N).
   * @param  {LatLon.datums} [datum] - Datum this coordinate is defined within.
   * @throws {TypeError} Unrecognised datum.
   *
   * @example
   *   import { Cartesian } from '/js/geodesy/latlon-ellipsoidal-datum.js';
   *   const coord = new Cartesian(3980581.210, -111.159, 4966824.522);
   */
  constructor(x, y, z, datum = void 0) {
    if (datum && datum.ellipsoid == void 0)
      throw new TypeError(`unrecognised datum ‘${datum}’`);
    super(x, y, z);
    if (datum)
      this._datum = datum;
  }
  /**
   * Datum this point is defined within.
   */
  get datum() {
    return this._datum;
  }
  set datum(datum) {
    if (!datum || datum.ellipsoid == void 0)
      throw new TypeError(`unrecognised datum ‘${datum}’`);
    this._datum = datum;
  }
  /**
   * Converts ‘this’ (geocentric) cartesian (x/y/z) coordinate to (geodetic) latitude/longitude
   * point (based on the same datum, or WGS84 if unset).
   *
   * Shadow of Cartesian.toLatLon(), returning LatLon augmented with LatLonEllipsoidal_Datum
   * methods convertDatum, toCartesian, etc.
   *
   * @returns {LatLon} Latitude/longitude point defined by cartesian coordinates.
   * @throws  {TypeError} Unrecognised datum
   *
   * @example
   *   const c = new Cartesian(4027893.924, 307041.993, 4919474.294);
   *   const p = c.toLatLon(); // 50.7978°N, 004.3592°E
   */
  toLatLon(deprecatedDatum = void 0) {
    if (deprecatedDatum) {
      console.info("datum parameter to Cartesian_Datum.toLatLon is deprecated: set datum before calling toLatLon()");
      this.datum = deprecatedDatum;
    }
    const datum = this.datum || datums2.WGS84;
    if (!datum || datum.ellipsoid == void 0)
      throw new TypeError(`unrecognised datum ‘${datum}’`);
    const latLon = super.toLatLon(datum.ellipsoid);
    const point = new LatLonEllipsoidal_Datum(latLon.lat, latLon.lon, latLon.height, this.datum);
    return point;
  }
  /**
   * Converts ‘this’ cartesian coordinate to new datum using Helmert 7-parameter transformation.
   *
   * @param   {LatLon.datums} toDatum - Datum this coordinate is to be converted to.
   * @returns {Cartesian} This point converted to new datum.
   * @throws  {Error} Undefined datum.
   *
   * @example
   *   const c = new Cartesian(3980574.247, -102.127, 4966830.065, LatLon.datums.OSGB36);
   *   c.convertDatum(LatLon.datums.Irl1975); // [??,??,??]
   */
  convertDatum(toDatum) {
    if (!toDatum || toDatum.ellipsoid == void 0)
      throw new TypeError(`unrecognised datum ‘${toDatum}’`);
    if (!this.datum)
      throw new TypeError("cartesian coordinate has no datum");
    let oldCartesian = null;
    let transform = null;
    if (this.datum == void 0 || this.datum == datums2.WGS84) {
      oldCartesian = this;
      transform = toDatum.transform;
    }
    if (toDatum == datums2.WGS84) {
      oldCartesian = this;
      transform = this.datum.transform.map((p) => -p);
    }
    if (transform == null) {
      oldCartesian = this.convertDatum(datums2.WGS84);
      transform = toDatum.transform;
    }
    const newCartesian = oldCartesian.applyTransform(transform);
    newCartesian.datum = toDatum;
    return newCartesian;
  }
  /**
   * Applies Helmert 7-parameter transformation to ‘this’ coordinate using transform parameters t.
   *
   * This is used in converting datums (geodetic->cartesian, apply transform, cartesian->geodetic).
   *
   * @private
   * @param   {number[]} t - Transformation to apply to this coordinate.
   * @returns {Cartesian} Transformed point.
   */
  applyTransform(t) {
    const { x: x1, y: y1, z: z1 } = this;
    const tx = t[0];
    const ty = t[1];
    const tz = t[2];
    const s = t[3] / 1e6 + 1;
    const rx = (t[4] / 3600).toRadians();
    const ry = (t[5] / 3600).toRadians();
    const rz = (t[6] / 3600).toRadians();
    const x2 = tx + x1 * s - y1 * rz + z1 * ry;
    const y2 = ty + x1 * rz + y1 * s - z1 * rx;
    const z2 = tz - x1 * ry + y1 * rx + z1 * s;
    return new _Cartesian_Datum(x2, y2, z2);
  }
};

export {
  LatLonEllipsoidal_Datum
};
//# sourceMappingURL=chunk-NPAZ35PB.js.map
