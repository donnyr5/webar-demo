{
  "version": 3,
  "sources": ["../../geodesy/dms.js"],
  "sourcesContent": ["/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/* Geodesy representation conversion functions                        (c) Chris Veness 2002-2020  */\n/*                                                                                   MIT Licence  */\n/* www.movable-type.co.uk/scripts/latlong.html                                                    */\n/* www.movable-type.co.uk/scripts/js/geodesy/geodesy-library.html#dms                             */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n/* eslint no-irregular-whitespace: [2, { skipComments: true }] */\n\n\n/**\n * Latitude/longitude points may be represented as decimal degrees, or subdivided into sexagesimal\n * minutes and seconds. This module provides methods for parsing and representing degrees / minutes\n * / seconds.\n *\n * @module dms\n */\n\n\n/* Degree-minutes-seconds (& cardinal directions) separator character */\nlet dmsSeparator = '\\u202f'; // U+202F = 'narrow no-break space'\n\n\n/**\n * Functions for parsing and representing degrees / minutes / seconds.\n */\nclass Dms {\n\n    // note Unicode Degree = U+00B0. Prime = U+2032, Double prime = U+2033\n\n    /**\n     * Separator character to be used to separate degrees, minutes, seconds, and cardinal directions.\n     *\n     * Default separator is U+202F ‘narrow no-break space’.\n     *\n     * To change this (e.g. to empty string or full space), set Dms.separator prior to invoking\n     * formatting.\n     *\n     * @example\n     *   import LatLon, { Dms } from '/js/geodesy/latlon-spherical.js';\n     *   const p = new LatLon(51.2, 0.33).toString('dms');  // 51° 12′ 00″ N, 000° 19′ 48″ E\n     *   Dms.separator = '';                                // no separator\n     *   const pʹ = new LatLon(51.2, 0.33).toString('dms'); // 51°12′00″N, 000°19′48″E\n     */\n    static get separator()     { return dmsSeparator; }\n    static set separator(char) { dmsSeparator = char; }\n\n\n    /**\n     * Parses string representing degrees/minutes/seconds into numeric degrees.\n     *\n     * This is very flexible on formats, allowing signed decimal degrees, or deg-min-sec optionally\n     * suffixed by compass direction (NSEW); a variety of separators are accepted. Examples -3.62,\n     * '3 37 12W', '3°37′12″W'.\n     *\n     * Thousands/decimal separators must be comma/dot; use Dms.fromLocale to convert locale-specific\n     * thousands/decimal separators.\n     *\n     * @param   {string|number} dms - Degrees or deg/min/sec in variety of formats.\n     * @returns {number}        Degrees as decimal number.\n     *\n     * @example\n     *   const lat = Dms.parse('51° 28′ 40.37″ N');\n     *   const lon = Dms.parse('000° 00′ 05.29″ W');\n     *   const p1 = new LatLon(lat, lon); // 51.4779°N, 000.0015°W\n     */\n    static parse(dms) {\n        // check for signed decimal degrees without NSEW, if so return it directly\n        if (!isNaN(parseFloat(dms)) && isFinite(dms)) return Number(dms);\n\n        // strip off any sign or compass dir'n & split out separate d/m/s\n        const dmsParts = String(dms).trim().replace(/^-/, '').replace(/[NSEW]$/i, '').split(/[^0-9.,]+/);\n        if (dmsParts[dmsParts.length-1]=='') dmsParts.splice(dmsParts.length-1);  // from trailing symbol\n\n        if (dmsParts == '') return NaN;\n\n        // and convert to decimal degrees...\n        let deg = null;\n        switch (dmsParts.length) {\n            case 3:  // interpret 3-part result as d/m/s\n                deg = dmsParts[0]/1 + dmsParts[1]/60 + dmsParts[2]/3600;\n                break;\n            case 2:  // interpret 2-part result as d/m\n                deg = dmsParts[0]/1 + dmsParts[1]/60;\n                break;\n            case 1:  // just d (possibly decimal) or non-separated dddmmss\n                deg = dmsParts[0];\n                // check for fixed-width unseparated format eg 0033709W\n                //if (/[NS]/i.test(dmsParts)) deg = '0' + deg;  // - normalise N/S to 3-digit degrees\n                //if (/[0-9]{7}/.test(deg)) deg = deg.slice(0,3)/1 + deg.slice(3,5)/60 + deg.slice(5)/3600;\n                break;\n            default:\n                return NaN;\n        }\n        if (/^-|[WS]$/i.test(dms.trim())) deg = -deg; // take '-', west and south as -ve\n\n        return Number(deg);\n    }\n\n\n    /**\n     * Converts decimal degrees to deg/min/sec format\n     *  - degree, prime, double-prime symbols are added, but sign is discarded, though no compass\n     *    direction is added.\n     *  - degrees are zero-padded to 3 digits; for degrees latitude, use .slice(1) to remove leading\n     *    zero.\n     *\n     * @private\n     * @param   {number} deg - Degrees to be formatted as specified.\n     * @param   {string} [format=d] - Return value as 'd', 'dm', 'dms' for deg, deg+min, deg+min+sec.\n     * @param   {number} [dp=4|2|0] - Number of decimal places to use – default 4 for d, 2 for dm, 0 for dms.\n     * @returns {string} Degrees formatted as deg/min/secs according to specified format.\n     */\n    static toDms(deg, format='d', dp=undefined) {\n        if (isNaN(deg)) return null;  // give up here if we can't make a number from deg\n        if (typeof deg == 'string' && deg.trim() == '') return null;\n        if (typeof deg == 'boolean') return null;\n        if (deg == Infinity) return null;\n        if (deg == null) return null;\n\n        // default values\n        if (dp === undefined) {\n            switch (format) {\n                case 'd':   case 'deg':         dp = 4; break;\n                case 'dm':  case 'deg+min':     dp = 2; break;\n                case 'dms': case 'deg+min+sec': dp = 0; break;\n                default:          format = 'd'; dp = 4; break; // be forgiving on invalid format\n            }\n        }\n\n        deg = Math.abs(deg);  // (unsigned result ready for appending compass dir'n)\n\n        let dms = null, d = null, m = null, s = null;\n        switch (format) {\n            default: // invalid format spec!\n            case 'd': case 'deg':\n                d = deg.toFixed(dp);                       // round/right-pad degrees\n                if (d<100) d = '0' + d;                    // left-pad with leading zeros (note may include decimals)\n                if (d<10) d = '0' + d;\n                dms = d + '°';\n                break;\n            case 'dm': case 'deg+min':\n                d = Math.floor(deg);                       // get component deg\n                m = ((deg*60) % 60).toFixed(dp);           // get component min & round/right-pad\n                if (m == 60) { m = (0).toFixed(dp); d++; } // check for rounding up\n                d = ('000'+d).slice(-3);                   // left-pad with leading zeros\n                if (m<10) m = '0' + m;                     // left-pad with leading zeros (note may include decimals)\n                dms = d + '°'+Dms.separator + m + '′';\n                break;\n            case 'dms': case 'deg+min+sec':\n                d = Math.floor(deg);                       // get component deg\n                m = Math.floor((deg*3600)/60) % 60;        // get component min\n                s = (deg*3600 % 60).toFixed(dp);           // get component sec & round/right-pad\n                if (s == 60) { s = (0).toFixed(dp); m++; } // check for rounding up\n                if (m == 60) { m = 0; d++; }               // check for rounding up\n                d = ('000'+d).slice(-3);                   // left-pad with leading zeros\n                m = ('00'+m).slice(-2);                    // left-pad with leading zeros\n                if (s<10) s = '0' + s;                     // left-pad with leading zeros (note may include decimals)\n                dms = d + '°'+Dms.separator + m + '′'+Dms.separator + s + '″';\n                break;\n        }\n\n        return dms;\n    }\n\n\n    /**\n     * Converts numeric degrees to deg/min/sec latitude (2-digit degrees, suffixed with N/S).\n     *\n     * @param   {number} deg - Degrees to be formatted as specified.\n     * @param   {string} [format=d] - Return value as 'd', 'dm', 'dms' for deg, deg+min, deg+min+sec.\n     * @param   {number} [dp=4|2|0] - Number of decimal places to use – default 4 for d, 2 for dm, 0 for dms.\n     * @returns {string} Degrees formatted as deg/min/secs according to specified format.\n     *\n     * @example\n     *   const lat = Dms.toLat(-3.62, 'dms'); // 3°37′12″S\n     */\n    static toLat(deg, format, dp) {\n        const lat = Dms.toDms(Dms.wrap90(deg), format, dp);\n        return lat===null ? '–' : lat.slice(1) + Dms.separator + (deg<0 ? 'S' : 'N');  // knock off initial '0' for lat!\n    }\n\n\n    /**\n     * Convert numeric degrees to deg/min/sec longitude (3-digit degrees, suffixed with E/W).\n     *\n     * @param   {number} deg - Degrees to be formatted as specified.\n     * @param   {string} [format=d] - Return value as 'd', 'dm', 'dms' for deg, deg+min, deg+min+sec.\n     * @param   {number} [dp=4|2|0] - Number of decimal places to use – default 4 for d, 2 for dm, 0 for dms.\n     * @returns {string} Degrees formatted as deg/min/secs according to specified format.\n     *\n     * @example\n     *   const lon = Dms.toLon(-3.62, 'dms'); // 3°37′12″W\n     */\n    static toLon(deg, format, dp) {\n        const lon = Dms.toDms(Dms.wrap180(deg), format, dp);\n        return lon===null ? '–' : lon + Dms.separator + (deg<0 ? 'W' : 'E');\n    }\n\n\n    /**\n     * Converts numeric degrees to deg/min/sec as a bearing (0°..360°).\n     *\n     * @param   {number} deg - Degrees to be formatted as specified.\n     * @param   {string} [format=d] - Return value as 'd', 'dm', 'dms' for deg, deg+min, deg+min+sec.\n     * @param   {number} [dp=4|2|0] - Number of decimal places to use – default 4 for d, 2 for dm, 0 for dms.\n     * @returns {string} Degrees formatted as deg/min/secs according to specified format.\n     *\n     * @example\n     *   const lon = Dms.toBrng(-3.62, 'dms'); // 356°22′48″\n     */\n    static toBrng(deg, format, dp) {\n        const brng =  Dms.toDms(Dms.wrap360(deg), format, dp);\n        return brng===null ? '–' : brng.replace('360', '0');  // just in case rounding took us up to 360°!\n    }\n\n\n    /**\n     * Converts DMS string from locale thousands/decimal separators to JavaScript comma/dot separators\n     * for subsequent parsing.\n     *\n     * Both thousands and decimal separators must be followed by a numeric character, to facilitate\n     * parsing of single lat/long string (in which whitespace must be left after the comma separator).\n     *\n     * @param   {string} str - Degrees/minutes/seconds formatted with locale separators.\n     * @returns {string} Degrees/minutes/seconds formatted with standard Javascript separators.\n     *\n     * @example\n     *   const lat = Dms.fromLocale('51°28′40,12″N');                          // '51°28′40.12″N' in France\n     *   const p = new LatLon(Dms.fromLocale('51°28′40,37″N, 000°00′05,29″W'); // '51.4779°N, 000.0015°W' in France\n     */\n    static fromLocale(str) {\n        const locale = (123456.789).toLocaleString();\n        const separator = { thousands: locale.slice(3, 4), decimal: locale.slice(7, 8) };\n        return str.replace(separator.thousands, '⁜').replace(separator.decimal, '.').replace('⁜', ',');\n    }\n\n\n    /**\n     * Converts DMS string from JavaScript comma/dot thousands/decimal separators to locale separators.\n     *\n     * Can also be used to format standard numbers such as distances.\n     *\n     * @param   {string} str - Degrees/minutes/seconds formatted with standard Javascript separators.\n     * @returns {string} Degrees/minutes/seconds formatted with locale separators.\n     *\n     * @example\n     *   const Dms.toLocale('123,456.789');                   // '123.456,789' in France\n     *   const Dms.toLocale('51°28′40.12″N, 000°00′05.31″W'); // '51°28′40,12″N, 000°00′05,31″W' in France\n     */\n    static toLocale(str) {\n        const locale = (123456.789).toLocaleString();\n        const separator = { thousands: locale.slice(3, 4), decimal: locale.slice(7, 8) };\n        return str.replace(/,([0-9])/, '⁜$1').replace('.', separator.decimal).replace('⁜', separator.thousands);\n    }\n\n\n    /**\n     * Returns compass point (to given precision) for supplied bearing.\n     *\n     * @param   {number} bearing - Bearing in degrees from north.\n     * @param   {number} [precision=3] - Precision (1:cardinal / 2:intercardinal / 3:secondary-intercardinal).\n     * @returns {string} Compass point for supplied bearing.\n     *\n     * @example\n     *   const point = Dms.compassPoint(24);    // point = 'NNE'\n     *   const point = Dms.compassPoint(24, 1); // point = 'N'\n     */\n    static compassPoint(bearing, precision=3) {\n        if (![ 1, 2, 3 ].includes(Number(precision))) throw new RangeError(`invalid precision ‘${precision}’`);\n        // note precision could be extended to 4 for quarter-winds (eg NbNW), but I think they are little used\n\n        bearing = Dms.wrap360(bearing); // normalise to range 0..360°\n\n        const cardinals = [\n            'N', 'NNE', 'NE', 'ENE',\n            'E', 'ESE', 'SE', 'SSE',\n            'S', 'SSW', 'SW', 'WSW',\n            'W', 'WNW', 'NW', 'NNW' ];\n        const n = 4 * 2**(precision-1); // no of compass points at req’d precision (1=>4, 2=>8, 3=>16)\n        const cardinal = cardinals[Math.round(bearing*n/360)%n * 16/n];\n\n        return cardinal;\n    }\n\n\n    /**\n     * Constrain degrees to range -90..+90 (for latitude); e.g. -91 => -89, 91 => 89.\n     *\n     * @private\n     * @param {number} degrees\n     * @returns degrees within range -90..+90.\n     */\n    static wrap90(degrees) {\n        if (-90<=degrees && degrees<=90) return degrees; // avoid rounding due to arithmetic ops if within range\n\n        // latitude wrapping requires a triangle wave function; a general triangle wave is\n        //     f(x) = 4a/p ⋅ | (x-p/4)%p - p/2 | - a\n        // where a = amplitude, p = period, % = modulo; however, JavaScript '%' is a remainder operator\n        // not a modulo operator - for modulo, replace 'x%n' with '((x%n)+n)%n'\n        const x = degrees, a = 90, p = 360;\n        return 4*a/p * Math.abs((((x-p/4)%p)+p)%p - p/2) - a;\n    }\n\n    /**\n     * Constrain degrees to range -180..+180 (for longitude); e.g. -181 => 179, 181 => -179.\n     *\n     * @private\n     * @param {number} degrees\n     * @returns degrees within range -180..+180.\n     */\n    static wrap180(degrees) {\n        if (-180<=degrees && degrees<=180) return degrees; // avoid rounding due to arithmetic ops if within range\n\n        // longitude wrapping requires a sawtooth wave function; a general sawtooth wave is\n        //     f(x) = (2ax/p - p/2) % p - a\n        // where a = amplitude, p = period, % = modulo; however, JavaScript '%' is a remainder operator\n        // not a modulo operator - for modulo, replace 'x%n' with '((x%n)+n)%n'\n        const x = degrees, a = 180, p = 360;\n        return (((2*a*x/p - p/2)%p)+p)%p - a;\n    }\n\n    /**\n     * Constrain degrees to range 0..360 (for bearings); e.g. -1 => 359, 361 => 1.\n     *\n     * @private\n     * @param {number} degrees\n     * @returns degrees within range 0..360.\n     */\n    static wrap360(degrees) {\n        if (0<=degrees && degrees<360) return degrees; // avoid rounding due to arithmetic ops if within range\n\n        // bearing wrapping requires a sawtooth wave function with a vertical offset equal to the\n        // amplitude and a corresponding phase shift; this changes the general sawtooth wave function from\n        //     f(x) = (2ax/p - p/2) % p - a\n        // to\n        //     f(x) = (2ax/p) % p\n        // where a = amplitude, p = period, % = modulo; however, JavaScript '%' is a remainder operator\n        // not a modulo operator - for modulo, replace 'x%n' with '((x%n)+n)%n'\n        const x = degrees, a = 180, p = 360;\n        return (((2*a*x/p)%p)+p)%p;\n    }\n\n}\n\n\n// Extend Number object with methods to convert between degrees & radians\nNumber.prototype.toRadians = function() { return this * Math.PI / 180; };\nNumber.prototype.toDegrees = function() { return this * 180 / Math.PI; };\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nexport default Dms;\n"],
  "mappings": "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",
  "names": []
}
