// node_modules/geodesy/dms.js
var dmsSeparator = " ";
var Dms = class _Dms {
  // note Unicode Degree = U+00B0. Prime = U+2032, Double prime = U+2033
  /**
   * Separator character to be used to separate degrees, minutes, seconds, and cardinal directions.
   *
   * Default separator is U+202F ‘narrow no-break space’.
   *
   * To change this (e.g. to empty string or full space), set Dms.separator prior to invoking
   * formatting.
   *
   * @example
   *   import LatLon, { Dms } from '/js/geodesy/latlon-spherical.js';
   *   const p = new LatLon(51.2, 0.33).toString('dms');  // 51° 12′ 00″ N, 000° 19′ 48″ E
   *   Dms.separator = '';                                // no separator
   *   const pʹ = new LatLon(51.2, 0.33).toString('dms'); // 51°12′00″N, 000°19′48″E
   */
  static get separator() {
    return dmsSeparator;
  }
  static set separator(char) {
    dmsSeparator = char;
  }
  /**
   * Parses string representing degrees/minutes/seconds into numeric degrees.
   *
   * This is very flexible on formats, allowing signed decimal degrees, or deg-min-sec optionally
   * suffixed by compass direction (NSEW); a variety of separators are accepted. Examples -3.62,
   * '3 37 12W', '3°37′12″W'.
   *
   * Thousands/decimal separators must be comma/dot; use Dms.fromLocale to convert locale-specific
   * thousands/decimal separators.
   *
   * @param   {string|number} dms - Degrees or deg/min/sec in variety of formats.
   * @returns {number}        Degrees as decimal number.
   *
   * @example
   *   const lat = Dms.parse('51° 28′ 40.37″ N');
   *   const lon = Dms.parse('000° 00′ 05.29″ W');
   *   const p1 = new LatLon(lat, lon); // 51.4779°N, 000.0015°W
   */
  static parse(dms) {
    if (!isNaN(parseFloat(dms)) && isFinite(dms))
      return Number(dms);
    const dmsParts = String(dms).trim().replace(/^-/, "").replace(/[NSEW]$/i, "").split(/[^0-9.,]+/);
    if (dmsParts[dmsParts.length - 1] == "")
      dmsParts.splice(dmsParts.length - 1);
    if (dmsParts == "")
      return NaN;
    let deg = null;
    switch (dmsParts.length) {
      case 3:
        deg = dmsParts[0] / 1 + dmsParts[1] / 60 + dmsParts[2] / 3600;
        break;
      case 2:
        deg = dmsParts[0] / 1 + dmsParts[1] / 60;
        break;
      case 1:
        deg = dmsParts[0];
        break;
      default:
        return NaN;
    }
    if (/^-|[WS]$/i.test(dms.trim()))
      deg = -deg;
    return Number(deg);
  }
  /**
   * Converts decimal degrees to deg/min/sec format
   *  - degree, prime, double-prime symbols are added, but sign is discarded, though no compass
   *    direction is added.
   *  - degrees are zero-padded to 3 digits; for degrees latitude, use .slice(1) to remove leading
   *    zero.
   *
   * @private
   * @param   {number} deg - Degrees to be formatted as specified.
   * @param   {string} [format=d] - Return value as 'd', 'dm', 'dms' for deg, deg+min, deg+min+sec.
   * @param   {number} [dp=4|2|0] - Number of decimal places to use – default 4 for d, 2 for dm, 0 for dms.
   * @returns {string} Degrees formatted as deg/min/secs according to specified format.
   */
  static toDms(deg, format = "d", dp = void 0) {
    if (isNaN(deg))
      return null;
    if (typeof deg == "string" && deg.trim() == "")
      return null;
    if (typeof deg == "boolean")
      return null;
    if (deg == Infinity)
      return null;
    if (deg == null)
      return null;
    if (dp === void 0) {
      switch (format) {
        case "d":
        case "deg":
          dp = 4;
          break;
        case "dm":
        case "deg+min":
          dp = 2;
          break;
        case "dms":
        case "deg+min+sec":
          dp = 0;
          break;
        default:
          format = "d";
          dp = 4;
          break;
      }
    }
    deg = Math.abs(deg);
    let dms = null, d = null, m = null, s = null;
    switch (format) {
      default:
      case "d":
      case "deg":
        d = deg.toFixed(dp);
        if (d < 100)
          d = "0" + d;
        if (d < 10)
          d = "0" + d;
        dms = d + "°";
        break;
      case "dm":
      case "deg+min":
        d = Math.floor(deg);
        m = (deg * 60 % 60).toFixed(dp);
        if (m == 60) {
          m = 0 .toFixed(dp);
          d++;
        }
        d = ("000" + d).slice(-3);
        if (m < 10)
          m = "0" + m;
        dms = d + "°" + _Dms.separator + m + "′";
        break;
      case "dms":
      case "deg+min+sec":
        d = Math.floor(deg);
        m = Math.floor(deg * 3600 / 60) % 60;
        s = (deg * 3600 % 60).toFixed(dp);
        if (s == 60) {
          s = 0 .toFixed(dp);
          m++;
        }
        if (m == 60) {
          m = 0;
          d++;
        }
        d = ("000" + d).slice(-3);
        m = ("00" + m).slice(-2);
        if (s < 10)
          s = "0" + s;
        dms = d + "°" + _Dms.separator + m + "′" + _Dms.separator + s + "″";
        break;
    }
    return dms;
  }
  /**
   * Converts numeric degrees to deg/min/sec latitude (2-digit degrees, suffixed with N/S).
   *
   * @param   {number} deg - Degrees to be formatted as specified.
   * @param   {string} [format=d] - Return value as 'd', 'dm', 'dms' for deg, deg+min, deg+min+sec.
   * @param   {number} [dp=4|2|0] - Number of decimal places to use – default 4 for d, 2 for dm, 0 for dms.
   * @returns {string} Degrees formatted as deg/min/secs according to specified format.
   *
   * @example
   *   const lat = Dms.toLat(-3.62, 'dms'); // 3°37′12″S
   */
  static toLat(deg, format, dp) {
    const lat = _Dms.toDms(_Dms.wrap90(deg), format, dp);
    return lat === null ? "–" : lat.slice(1) + _Dms.separator + (deg < 0 ? "S" : "N");
  }
  /**
   * Convert numeric degrees to deg/min/sec longitude (3-digit degrees, suffixed with E/W).
   *
   * @param   {number} deg - Degrees to be formatted as specified.
   * @param   {string} [format=d] - Return value as 'd', 'dm', 'dms' for deg, deg+min, deg+min+sec.
   * @param   {number} [dp=4|2|0] - Number of decimal places to use – default 4 for d, 2 for dm, 0 for dms.
   * @returns {string} Degrees formatted as deg/min/secs according to specified format.
   *
   * @example
   *   const lon = Dms.toLon(-3.62, 'dms'); // 3°37′12″W
   */
  static toLon(deg, format, dp) {
    const lon = _Dms.toDms(_Dms.wrap180(deg), format, dp);
    return lon === null ? "–" : lon + _Dms.separator + (deg < 0 ? "W" : "E");
  }
  /**
   * Converts numeric degrees to deg/min/sec as a bearing (0°..360°).
   *
   * @param   {number} deg - Degrees to be formatted as specified.
   * @param   {string} [format=d] - Return value as 'd', 'dm', 'dms' for deg, deg+min, deg+min+sec.
   * @param   {number} [dp=4|2|0] - Number of decimal places to use – default 4 for d, 2 for dm, 0 for dms.
   * @returns {string} Degrees formatted as deg/min/secs according to specified format.
   *
   * @example
   *   const lon = Dms.toBrng(-3.62, 'dms'); // 356°22′48″
   */
  static toBrng(deg, format, dp) {
    const brng = _Dms.toDms(_Dms.wrap360(deg), format, dp);
    return brng === null ? "–" : brng.replace("360", "0");
  }
  /**
   * Converts DMS string from locale thousands/decimal separators to JavaScript comma/dot separators
   * for subsequent parsing.
   *
   * Both thousands and decimal separators must be followed by a numeric character, to facilitate
   * parsing of single lat/long string (in which whitespace must be left after the comma separator).
   *
   * @param   {string} str - Degrees/minutes/seconds formatted with locale separators.
   * @returns {string} Degrees/minutes/seconds formatted with standard Javascript separators.
   *
   * @example
   *   const lat = Dms.fromLocale('51°28′40,12″N');                          // '51°28′40.12″N' in France
   *   const p = new LatLon(Dms.fromLocale('51°28′40,37″N, 000°00′05,29″W'); // '51.4779°N, 000.0015°W' in France
   */
  static fromLocale(str) {
    const locale = 123456.789.toLocaleString();
    const separator = { thousands: locale.slice(3, 4), decimal: locale.slice(7, 8) };
    return str.replace(separator.thousands, "⁜").replace(separator.decimal, ".").replace("⁜", ",");
  }
  /**
   * Converts DMS string from JavaScript comma/dot thousands/decimal separators to locale separators.
   *
   * Can also be used to format standard numbers such as distances.
   *
   * @param   {string} str - Degrees/minutes/seconds formatted with standard Javascript separators.
   * @returns {string} Degrees/minutes/seconds formatted with locale separators.
   *
   * @example
   *   const Dms.toLocale('123,456.789');                   // '123.456,789' in France
   *   const Dms.toLocale('51°28′40.12″N, 000°00′05.31″W'); // '51°28′40,12″N, 000°00′05,31″W' in France
   */
  static toLocale(str) {
    const locale = 123456.789.toLocaleString();
    const separator = { thousands: locale.slice(3, 4), decimal: locale.slice(7, 8) };
    return str.replace(/,([0-9])/, "⁜$1").replace(".", separator.decimal).replace("⁜", separator.thousands);
  }
  /**
   * Returns compass point (to given precision) for supplied bearing.
   *
   * @param   {number} bearing - Bearing in degrees from north.
   * @param   {number} [precision=3] - Precision (1:cardinal / 2:intercardinal / 3:secondary-intercardinal).
   * @returns {string} Compass point for supplied bearing.
   *
   * @example
   *   const point = Dms.compassPoint(24);    // point = 'NNE'
   *   const point = Dms.compassPoint(24, 1); // point = 'N'
   */
  static compassPoint(bearing, precision = 3) {
    if (![1, 2, 3].includes(Number(precision)))
      throw new RangeError(`invalid precision ‘${precision}’`);
    bearing = _Dms.wrap360(bearing);
    const cardinals = [
      "N",
      "NNE",
      "NE",
      "ENE",
      "E",
      "ESE",
      "SE",
      "SSE",
      "S",
      "SSW",
      "SW",
      "WSW",
      "W",
      "WNW",
      "NW",
      "NNW"
    ];
    const n = 4 * 2 ** (precision - 1);
    const cardinal = cardinals[Math.round(bearing * n / 360) % n * 16 / n];
    return cardinal;
  }
  /**
   * Constrain degrees to range -90..+90 (for latitude); e.g. -91 => -89, 91 => 89.
   *
   * @private
   * @param {number} degrees
   * @returns degrees within range -90..+90.
   */
  static wrap90(degrees) {
    if (-90 <= degrees && degrees <= 90)
      return degrees;
    const x = degrees, a = 90, p = 360;
    return 4 * a / p * Math.abs(((x - p / 4) % p + p) % p - p / 2) - a;
  }
  /**
   * Constrain degrees to range -180..+180 (for longitude); e.g. -181 => 179, 181 => -179.
   *
   * @private
   * @param {number} degrees
   * @returns degrees within range -180..+180.
   */
  static wrap180(degrees) {
    if (-180 <= degrees && degrees <= 180)
      return degrees;
    const x = degrees, a = 180, p = 360;
    return ((2 * a * x / p - p / 2) % p + p) % p - a;
  }
  /**
   * Constrain degrees to range 0..360 (for bearings); e.g. -1 => 359, 361 => 1.
   *
   * @private
   * @param {number} degrees
   * @returns degrees within range 0..360.
   */
  static wrap360(degrees) {
    if (0 <= degrees && degrees < 360)
      return degrees;
    const x = degrees, a = 180, p = 360;
    return (2 * a * x / p % p + p) % p;
  }
};
Number.prototype.toRadians = function() {
  return this * Math.PI / 180;
};
Number.prototype.toDegrees = function() {
  return this * 180 / Math.PI;
};
var dms_default = Dms;

export {
  dms_default
};
//# sourceMappingURL=chunk-GIFWOSH2.js.map
