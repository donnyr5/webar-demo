{
  "version": 3,
  "sources": ["../../geodesy/vector3d.js", "../../geodesy/latlon-ellipsoidal.js", "../../geodesy/latlon-ellipsoidal-datum.js"],
  "sourcesContent": ["/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/* Vector handling functions                                          (c) Chris Veness 2011-2019  */\n/*                                                                                   MIT Licence  */\n/* www.movable-type.co.uk/scripts/geodesy-library.html#vector3d                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n\n/**\n * Library of 3-d vector manipulation routines.\n *\n * @module vector3d\n */\n\n\n/* Vector3d - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n\n/**\n * Functions for manipulating generic 3-d vectors.\n *\n * Functions return vectors as return results, so that operations can be chained.\n *\n * @example\n *   const v = v1.cross(v2).dot(v3) // ≡ v1×v2⋅v3\n */\nclass Vector3d {\n\n    /**\n     * Creates a 3-d vector.\n     *\n     * @param {number} x - X component of vector.\n     * @param {number} y - Y component of vector.\n     * @param {number} z - Z component of vector.\n     *\n     * @example\n     *   import Vector3d from '/js/geodesy/vector3d.js';\n     *   const v = new Vector3d(0.267, 0.535, 0.802);\n     */\n    constructor(x, y, z) {\n        if (isNaN(x) || isNaN(y) || isNaN(z)) throw new TypeError(`invalid vector [${x},${y},${z}]`);\n\n        this.x = Number(x);\n        this.y = Number(y);\n        this.z = Number(z);\n    }\n\n\n    /**\n     * Length (magnitude or norm) of ‘this’ vector.\n     *\n     * @returns {number} Magnitude of this vector.\n     */\n    get length() {\n        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n    }\n\n\n    /**\n     * Adds supplied vector to ‘this’ vector.\n     *\n     * @param   {Vector3d} v - Vector to be added to this vector.\n     * @returns {Vector3d} Vector representing sum of this and v.\n     */\n    plus(v) {\n        if (!(v instanceof Vector3d)) throw new TypeError('v is not Vector3d object');\n\n        return new Vector3d(this.x + v.x, this.y + v.y, this.z + v.z);\n    }\n\n\n    /**\n     * Subtracts supplied vector from ‘this’ vector.\n     *\n     * @param   {Vector3d} v - Vector to be subtracted from this vector.\n     * @returns {Vector3d} Vector representing difference between this and v.\n     */\n    minus(v) {\n        if (!(v instanceof Vector3d)) throw new TypeError('v is not Vector3d object');\n\n        return new Vector3d(this.x - v.x, this.y - v.y, this.z - v.z);\n    }\n\n\n    /**\n     * Multiplies ‘this’ vector by a scalar value.\n     *\n     * @param   {number}   x - Factor to multiply this vector by.\n     * @returns {Vector3d} Vector scaled by x.\n     */\n    times(x) {\n        if (isNaN(x)) throw new TypeError(`invalid scalar value ‘${x}’`);\n\n        return new Vector3d(this.x * x, this.y * x, this.z * x);\n    }\n\n\n    /**\n     * Divides ‘this’ vector by a scalar value.\n     *\n     * @param   {number}   x - Factor to divide this vector by.\n     * @returns {Vector3d} Vector divided by x.\n     */\n    dividedBy(x) {\n        if (isNaN(x)) throw new TypeError(`invalid scalar value ‘${x}’`);\n\n        return new Vector3d(this.x / x, this.y / x, this.z / x);\n    }\n\n\n    /**\n     * Multiplies ‘this’ vector by the supplied vector using dot (scalar) product.\n     *\n     * @param   {Vector3d} v - Vector to be dotted with this vector.\n     * @returns {number}   Dot product of ‘this’ and v.\n     */\n    dot(v) {\n        if (!(v instanceof Vector3d)) throw new TypeError('v is not Vector3d object');\n\n        return this.x * v.x + this.y * v.y + this.z * v.z;\n    }\n\n\n    /**\n     * Multiplies ‘this’ vector by the supplied vector using cross (vector) product.\n     *\n     * @param   {Vector3d} v - Vector to be crossed with this vector.\n     * @returns {Vector3d} Cross product of ‘this’ and v.\n     */\n    cross(v) {\n        if (!(v instanceof Vector3d)) throw new TypeError('v is not Vector3d object');\n\n        const x = this.y * v.z - this.z * v.y;\n        const y = this.z * v.x - this.x * v.z;\n        const z = this.x * v.y - this.y * v.x;\n\n        return new Vector3d(x, y, z);\n    }\n\n\n    /**\n     * Negates a vector to point in the opposite direction.\n     *\n     * @returns {Vector3d} Negated vector.\n     */\n    negate() {\n        return new Vector3d(-this.x, -this.y, -this.z);\n    }\n\n\n    /**\n     * Normalizes a vector to its unit vector\n     * – if the vector is already unit or is zero magnitude, this is a no-op.\n     *\n     * @returns {Vector3d} Normalised version of this vector.\n     */\n    unit() {\n        const norm = this.length;\n        if (norm == 1) return this;\n        if (norm == 0) return this;\n\n        const x = this.x / norm;\n        const y = this.y / norm;\n        const z = this.z / norm;\n\n        return new Vector3d(x, y, z);\n    }\n\n\n    /**\n     * Calculates the angle between ‘this’ vector and supplied vector atan2(|p₁×p₂|, p₁·p₂) (or if\n     * (extra-planar) ‘n’ supplied then atan2(n·p₁×p₂, p₁·p₂).\n     *\n     * @param   {Vector3d} v - Vector whose angle is to be determined from ‘this’ vector.\n     * @param   {Vector3d} [n] - Plane normal: if supplied, angle is signed +ve if this->v is\n     *                     clockwise looking along n, -ve in opposite direction.\n     * @returns {number}   Angle (in radians) between this vector and supplied vector (in range 0..π\n     *                     if n not supplied, range -π..+π if n supplied).\n     */\n    angleTo(v, n=undefined) {\n        if (!(v instanceof Vector3d)) throw new TypeError('v is not Vector3d object');\n        if (!(n instanceof Vector3d || n == undefined)) throw new TypeError('n is not Vector3d object');\n\n        // q.v. stackoverflow.com/questions/14066933#answer-16544330, but n·p₁×p₂ is numerically\n        // ill-conditioned, so just calculate sign to apply to |p₁×p₂|\n\n        // if n·p₁×p₂ is -ve, negate |p₁×p₂|\n        const sign = n==undefined || this.cross(v).dot(n)>=0 ? 1 : -1;\n\n        const sinθ = this.cross(v).length * sign;\n        const cosθ = this.dot(v);\n\n        return Math.atan2(sinθ, cosθ);\n    }\n\n\n    /**\n     * Rotates ‘this’ point around an axis by a specified angle.\n     *\n     * @param   {Vector3d} axis - The axis being rotated around.\n     * @param   {number}   angle - The angle of rotation (in degrees).\n     * @returns {Vector3d} The rotated point.\n     */\n    rotateAround(axis, angle) {\n        if (!(axis instanceof Vector3d)) throw new TypeError('axis is not Vector3d object');\n\n        const θ = angle.toRadians();\n\n        // en.wikipedia.org/wiki/Rotation_matrix#Rotation_matrix_from_axis_and_angle\n        // en.wikipedia.org/wiki/Quaternions_and_spatial_rotation#Quaternion-derived_rotation_matrix\n        const p = this.unit();\n        const a = axis.unit();\n\n        const s = Math.sin(θ);\n        const c = Math.cos(θ);\n        const t = 1-c;\n        const x = a.x, y = a.y, z = a.z;\n\n        const r = [ // rotation matrix for rotation about supplied axis\n            [ t*x*x + c,   t*x*y - s*z, t*x*z + s*y ],\n            [ t*x*y + s*z, t*y*y + c,   t*y*z - s*x ],\n            [ t*x*z - s*y, t*y*z + s*x, t*z*z + c   ],\n        ];\n\n        // multiply r × p\n        const rp = [\n            r[0][0]*p.x + r[0][1]*p.y + r[0][2]*p.z,\n            r[1][0]*p.x + r[1][1]*p.y + r[1][2]*p.z,\n            r[2][0]*p.x + r[2][1]*p.y + r[2][2]*p.z,\n        ];\n        const p2 = new Vector3d(rp[0], rp[1], rp[2]);\n\n        return p2;\n        // qv en.wikipedia.org/wiki/Rodrigues'_rotation_formula...\n    }\n\n\n    /**\n     * String representation of vector.\n     *\n     * @param   {number} [dp=3] - Number of decimal places to be used.\n     * @returns {string} Vector represented as [x,y,z].\n     */\n    toString(dp=3) {\n        return `[${this.x.toFixed(dp)},${this.y.toFixed(dp)},${this.z.toFixed(dp)}]`;\n    }\n\n}\n\n\n// Extend Number object with methods to convert between degrees & radians\nNumber.prototype.toRadians = function() { return this * Math.PI / 180; };\nNumber.prototype.toDegrees = function() { return this * 180 / Math.PI; };\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nexport default Vector3d;\n", "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/* Geodesy tools for an ellipsoidal earth model                       (c) Chris Veness 2005-2022  */\n/*                                                                                   MIT Licence  */\n/* Core class for latlon-ellipsoidal-datum & latlon-ellipsoidal-referenceframe.                   */\n/*                                                                                                */\n/* www.movable-type.co.uk/scripts/latlong-convert-coords.html                                     */\n/* www.movable-type.co.uk/scripts/geodesy-library.html#latlon-ellipsoidal                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nimport Dms      from './dms.js';\nimport Vector3d from './vector3d.js';\n\n\n/**\n * A latitude/longitude point defines a geographic location on or above/below the earth’s surface,\n * measured in degrees from the equator & the International Reference Meridian and in metres above\n * the ellipsoid, and based on a given datum.\n *\n * As so much modern geodesy is based on WGS-84 (as used by GPS), this module includes WGS-84\n * ellipsoid parameters, and it has methods for converting geodetic (latitude/longitude) points to/from\n * geocentric cartesian points; the latlon-ellipsoidal-datum and latlon-ellipsoidal-referenceframe\n * modules provide transformation parameters for converting between historical datums and between\n * modern reference frames.\n *\n * This module is used for both trigonometric geodesy (eg latlon-ellipsoidal-vincenty) and n-vector\n * geodesy (eg latlon-nvector-ellipsoidal), and also for UTM/MGRS mapping.\n *\n * @module latlon-ellipsoidal\n */\n\n\n/*\n * Ellipsoid parameters; exposed through static getter below.\n *\n * The only ellipsoid defined is WGS84, for use in utm/mgrs, vincenty, nvector.\n */\nconst ellipsoids = {\n    WGS84: { a: 6378137, b: 6356752.314245, f: 1/298.257223563 },\n};\n\n\n/*\n * Datums; exposed through static getter below.\n *\n * The only datum defined is WGS84, for use in utm/mgrs, vincenty, nvector.\n */\nconst datums = {\n    WGS84: { ellipsoid: ellipsoids.WGS84 },\n};\n\n\n// freeze static properties\nObject.freeze(ellipsoids.WGS84);\nObject.freeze(datums.WGS84);\n\n\n/* LatLonEllipsoidal - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n\n/**\n * Latitude/longitude points on an ellipsoidal model earth, with ellipsoid parameters and methods\n * for converting points to/from cartesian (ECEF) coordinates.\n *\n * This is the core class, which will usually be used via LatLonEllipsoidal_Datum or\n * LatLonEllipsoidal_ReferenceFrame.\n */\nclass LatLonEllipsoidal {\n\n    /**\n     * Creates a geodetic latitude/longitude point on a (WGS84) ellipsoidal model earth.\n     *\n     * @param  {number} lat - Latitude (in degrees).\n     * @param  {number} lon - Longitude (in degrees).\n     * @param  {number} [height=0] - Height above ellipsoid in metres.\n     * @throws {TypeError} Invalid lat/lon/height.\n     *\n     * @example\n     *   import LatLon from '/js/geodesy/latlon-ellipsoidal.js';\n     *   const p = new LatLon(51.47788, -0.00147, 17);\n     */\n    constructor(lat, lon, height=0) {\n        if (isNaN(lat) || lat == null) throw new TypeError(`invalid lat ‘${lat}’`);\n        if (isNaN(lon) || lon == null) throw new TypeError(`invalid lon ‘${lon}’`);\n        if (isNaN(height) || height == null) throw new TypeError(`invalid height ‘${height}’`);\n\n        this._lat = Dms.wrap90(Number(lat));\n        this._lon = Dms.wrap180(Number(lon));\n        this._height = Number(height);\n    }\n\n\n    /**\n     * Latitude in degrees north from equator (including aliases lat, latitude): can be set as\n     * numeric or hexagesimal (deg-min-sec); returned as numeric.\n     */\n    get lat()       { return this._lat; }\n    get latitude()  { return this._lat; }\n    set lat(lat) {\n        this._lat = isNaN(lat) ? Dms.wrap90(Dms.parse(lat)) : Dms.wrap90(Number(lat));\n        if (isNaN(this._lat)) throw new TypeError(`invalid lat ‘${lat}’`);\n    }\n    set latitude(lat) {\n        this._lat = isNaN(lat) ? Dms.wrap90(Dms.parse(lat)) : Dms.wrap90(Number(lat));\n        if (isNaN(this._lat)) throw new TypeError(`invalid latitude ‘${lat}’`);\n    }\n\n    /**\n     * Longitude in degrees east from international reference meridian (including aliases lon, lng,\n     * longitude): can be set as numeric or hexagesimal (deg-min-sec); returned as numeric.\n     */\n    get lon()       { return this._lon; }\n    get lng()       { return this._lon; }\n    get longitude() { return this._lon; }\n    set lon(lon) {\n        this._lon = isNaN(lon) ? Dms.wrap180(Dms.parse(lon)) : Dms.wrap180(Number(lon));\n        if (isNaN(this._lon)) throw new TypeError(`invalid lon ‘${lon}’`);\n    }\n    set lng(lon) {\n        this._lon = isNaN(lon) ? Dms.wrap180(Dms.parse(lon)) : Dms.wrap180(Number(lon));\n        if (isNaN(this._lon)) throw new TypeError(`invalid lng ‘${lon}’`);\n    }\n    set longitude(lon) {\n        this._lon = isNaN(lon) ? Dms.wrap180(Dms.parse(lon)) : Dms.wrap180(Number(lon));\n        if (isNaN(this._lon)) throw new TypeError(`invalid longitude ‘${lon}’`);\n    }\n\n    /**\n     * Height in metres above ellipsoid.\n     */\n    get height()       { return this._height; }\n    set height(height) { this._height = Number(height); if (isNaN(this._height)) throw new TypeError(`invalid height ‘${height}’`); }\n\n\n    /**\n     * Datum.\n     *\n     * Note this is replicated within LatLonEllipsoidal in order that a LatLonEllipsoidal object can\n     * be monkey-patched to look like a LatLonEllipsoidal_Datum, for Vincenty calculations on\n     * different ellipsoids.\n     *\n     * @private\n     */\n    get datum()      { return this._datum; }\n    set datum(datum) { this._datum = datum; }\n\n\n    /**\n     * Ellipsoids with their parameters; this module only defines WGS84 parameters a = 6378137, b =\n     * 6356752.314245, f = 1/298.257223563.\n     *\n     * @example\n     *   const a = LatLon.ellipsoids.WGS84.a; // 6378137\n     */\n    static get ellipsoids() {\n        return ellipsoids;\n    }\n\n    /**\n     * Datums; this module only defines WGS84 datum, hence no datum transformations.\n     *\n     * @example\n     *   const a = LatLon.datums.WGS84.ellipsoid.a; // 6377563.396\n     */\n    static get datums() {\n        return datums;\n    }\n\n\n    /**\n     * Parses a latitude/longitude point from a variety of formats.\n     *\n     * Latitude & longitude (in degrees) can be supplied as two separate parameters, as a single\n     * comma-separated lat/lon string, or as a single object with { lat, lon } or GeoJSON properties.\n     *\n     * The latitude/longitude values may be numeric or strings; they may be signed decimal or\n     * deg-min-sec (hexagesimal) suffixed by compass direction (NSEW); a variety of separators are\n     * accepted. Examples -3.62, '3 37 12W', '3°37′12″W'.\n     *\n     * Thousands/decimal separators must be comma/dot; use Dms.fromLocale to convert locale-specific\n     * thousands/decimal separators.\n     *\n     * @param   {number|string|Object} lat|latlon - Latitude (in degrees), or comma-separated lat/lon, or lat/lon object.\n     * @param   {number}               [lon]      - Longitude (in degrees).\n     * @param   {number}               [height=0] - Height above ellipsoid in metres.\n     * @returns {LatLon} Latitude/longitude point on WGS84 ellipsoidal model earth.\n     * @throws  {TypeError} Invalid coordinate.\n     *\n     * @example\n     *   const p1 = LatLon.parse(51.47788, -0.00147);              // numeric pair\n     *   const p2 = LatLon.parse('51°28′40″N, 000°00′05″W', 17);   // dms string + height\n     *   const p3 = LatLon.parse({ lat: 52.205, lon: 0.119 }, 17); // { lat, lon } object numeric + height\n     */\n    static parse(...args) {\n        if (args.length == 0) throw new TypeError('invalid (empty) point');\n\n        let lat=undefined, lon=undefined, height=undefined;\n\n        // single { lat, lon } object\n        if (typeof args[0]=='object' && (args.length==1 || !isNaN(parseFloat(args[1])))) {\n            const ll = args[0];\n            if (ll.type == 'Point' && Array.isArray(ll.coordinates)) { // GeoJSON\n                [ lon, lat, height ] = ll.coordinates;\n                height = height || 0;\n            } else { // regular { lat, lon } object\n                if (ll.latitude  != undefined) lat = ll.latitude;\n                if (ll.lat       != undefined) lat = ll.lat;\n                if (ll.longitude != undefined) lon = ll.longitude;\n                if (ll.lng       != undefined) lon = ll.lng;\n                if (ll.lon       != undefined) lon = ll.lon;\n                if (ll.height    != undefined) height = ll.height;\n                lat = Dms.wrap90(Dms.parse(lat));\n                lon = Dms.wrap180(Dms.parse(lon));\n            }\n            if (args[1] != undefined) height = args[1];\n            if (isNaN(lat) || isNaN(lon)) throw new TypeError(`invalid point ‘${JSON.stringify(args[0])}’`);\n        }\n\n        // single comma-separated lat/lon\n        if (typeof args[0] == 'string' && args[0].split(',').length == 2) {\n            [ lat, lon ] = args[0].split(',');\n            lat = Dms.wrap90(Dms.parse(lat));\n            lon = Dms.wrap180(Dms.parse(lon));\n            height = args[1] || 0;\n            if (isNaN(lat) || isNaN(lon)) throw new TypeError(`invalid point ‘${args[0]}’`);\n        }\n\n        // regular (lat, lon) arguments\n        if (lat==undefined && lon==undefined) {\n            [ lat, lon ] = args;\n            lat = Dms.wrap90(Dms.parse(lat));\n            lon = Dms.wrap180(Dms.parse(lon));\n            height = args[2] || 0;\n            if (isNaN(lat) || isNaN(lon)) throw new TypeError(`invalid point ‘${args.toString()}’`);\n        }\n\n        return new this(lat, lon, height); // 'new this' as may return subclassed types\n    }\n\n\n    /**\n     * Converts ‘this’ point from (geodetic) latitude/longitude coordinates to (geocentric)\n     * cartesian (x/y/z) coordinates.\n     *\n     * @returns {Cartesian} Cartesian point equivalent to lat/lon point, with x, y, z in metres from\n     *   earth centre.\n     */\n    toCartesian() {\n        // x = (ν+h)⋅cosφ⋅cosλ, y = (ν+h)⋅cosφ⋅sinλ, z = (ν⋅(1-e²)+h)⋅sinφ\n        // where ν = a/√(1−e²⋅sinφ⋅sinφ), e² = (a²-b²)/a² or (better conditioned) 2⋅f-f²\n        const ellipsoid = this.datum\n            ? this.datum.ellipsoid\n            : this.referenceFrame ? this.referenceFrame.ellipsoid : ellipsoids.WGS84;\n\n        const φ = this.lat.toRadians();\n        const λ = this.lon.toRadians();\n        const h = this.height;\n        const { a, f } = ellipsoid;\n\n        const sinφ = Math.sin(φ), cosφ = Math.cos(φ);\n        const sinλ = Math.sin(λ), cosλ = Math.cos(λ);\n\n        const eSq = 2*f - f*f;                      // 1st eccentricity squared ≡ (a²-b²)/a²\n        const ν = a / Math.sqrt(1 - eSq*sinφ*sinφ); // radius of curvature in prime vertical\n\n        const x = (ν+h) * cosφ * cosλ;\n        const y = (ν+h) * cosφ * sinλ;\n        const z = (ν*(1-eSq)+h) * sinφ;\n\n        return new Cartesian(x, y, z);\n    }\n\n\n    /**\n     * Checks if another point is equal to ‘this’ point.\n     *\n     * @param   {LatLon} point - Point to be compared against this point.\n     * @returns {bool} True if points have identical latitude, longitude, height, and datum/referenceFrame.\n     * @throws  {TypeError} Invalid point.\n     *\n     * @example\n     *   const p1 = new LatLon(52.205, 0.119);\n     *   const p2 = new LatLon(52.205, 0.119);\n     *   const equal = p1.equals(p2); // true\n     */\n    equals(point) {\n        if (!(point instanceof LatLonEllipsoidal)) throw new TypeError(`invalid point ‘${point}’`);\n\n        if (Math.abs(this.lat - point.lat) > Number.EPSILON) return false;\n        if (Math.abs(this.lon - point.lon) > Number.EPSILON) return false;\n        if (Math.abs(this.height - point.height) > Number.EPSILON) return false;\n        if (this.datum != point.datum) return false;\n        if (this.referenceFrame != point.referenceFrame) return false;\n        if (this.epoch != point.epoch) return false;\n\n        return true;\n    }\n\n\n    /**\n     * Returns a string representation of ‘this’ point, formatted as degrees, degrees+minutes, or\n     * degrees+minutes+seconds.\n     *\n     * @param   {string} [format=d] - Format point as 'd', 'dm', 'dms', or 'n' for signed numeric.\n     * @param   {number} [dp=4|2|0] - Number of decimal places to use: default 4 for d, 2 for dm, 0 for dms.\n     * @param   {number} [dpHeight=null] - Number of decimal places to use for height; default is no height display.\n     * @returns {string} Comma-separated formatted latitude/longitude.\n     * @throws  {RangeError} Invalid format.\n     *\n     * @example\n     *   const greenwich = new LatLon(51.47788, -0.00147, 46);\n     *   const d = greenwich.toString();                        // 51.4779°N, 000.0015°W\n     *   const dms = greenwich.toString('dms', 2);              // 51°28′40″N, 000°00′05″W\n     *   const [lat, lon] = greenwich.toString('n').split(','); // 51.4779, -0.0015\n     *   const dmsh = greenwich.toString('dms', 0, 0);          // 51°28′40″N, 000°00′06″W +46m\n     */\n    toString(format='d', dp=undefined, dpHeight=null) {\n        // note: explicitly set dp to undefined for passing through to toLat/toLon\n        if (![ 'd', 'dm', 'dms', 'n' ].includes(format)) throw new RangeError(`invalid format ‘${format}’`);\n\n        const height = (this.height>=0 ? ' +' : ' ') + this.height.toFixed(dpHeight) + 'm';\n        if (format == 'n') { // signed numeric degrees\n            if (dp == undefined) dp = 4;\n            const lat = this.lat.toFixed(dp);\n            const lon = this.lon.toFixed(dp);\n            return `${lat}, ${lon}${dpHeight==null ? '' : height}`;\n        }\n\n        const lat = Dms.toLat(this.lat, format, dp);\n        const lon = Dms.toLon(this.lon, format, dp);\n\n        return `${lat}, ${lon}${dpHeight==null ? '' : height}`;\n    }\n\n}\n\n\n/* Cartesian  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n\n/**\n * ECEF (earth-centered earth-fixed) geocentric cartesian coordinates.\n *\n * @extends Vector3d\n */\nclass Cartesian extends Vector3d {\n\n    /**\n     * Creates cartesian coordinate representing ECEF (earth-centric earth-fixed) point.\n     *\n     * @param {number} x - X coordinate in metres (=> 0°N,0°E).\n     * @param {number} y - Y coordinate in metres (=> 0°N,90°E).\n     * @param {number} z - Z coordinate in metres (=> 90°N).\n     *\n     * @example\n     *   import { Cartesian } from '/js/geodesy/latlon-ellipsoidal.js';\n     *   const coord = new Cartesian(3980581.210, -111.159, 4966824.522);\n     */\n    constructor(x, y, z) {\n        super(x, y, z); // arguably redundant constructor, but specifies units & axes\n    }\n\n\n    /**\n     * Converts ‘this’ (geocentric) cartesian (x/y/z) coordinate to (geodetic) latitude/longitude\n     * point on specified ellipsoid.\n     *\n     * Uses Bowring’s (1985) formulation for μm precision in concise form; ‘The accuracy of geodetic\n     * latitude and height equations’, B R Bowring, Survey Review vol 28, 218, Oct 1985.\n     *\n     * @param   {LatLon.ellipsoids} [ellipsoid=WGS84] - Ellipsoid to use when converting point.\n     * @returns {LatLon} Latitude/longitude point defined by cartesian coordinates, on given ellipsoid.\n     * @throws  {TypeError} Invalid ellipsoid.\n     *\n     * @example\n     *   const c = new Cartesian(4027893.924, 307041.993, 4919474.294);\n     *   const p = c.toLatLon(); // 50.7978°N, 004.3592°E\n     */\n    toLatLon(ellipsoid=ellipsoids.WGS84) {\n        // note ellipsoid is available as a parameter for when toLatLon gets subclassed to\n        // Ellipsoidal_Datum / Ellipsoidal_Referenceframe.\n        if (!ellipsoid || !ellipsoid.a) throw new TypeError(`invalid ellipsoid ‘${ellipsoid}’`);\n\n        const { x, y, z } = this;\n        const { a, b, f } = ellipsoid;\n\n        const e2 = 2*f - f*f;           // 1st eccentricity squared ≡ (a²−b²)/a²\n        const ε2 = e2 / (1-e2);         // 2nd eccentricity squared ≡ (a²−b²)/b²\n        const p = Math.sqrt(x*x + y*y); // distance from minor axis\n        const R = Math.sqrt(p*p + z*z); // polar radius\n\n        // parametric latitude (Bowring eqn.17, replacing tanβ = z·a / p·b)\n        const tanβ = (b*z)/(a*p) * (1+ε2*b/R);\n        const sinβ = tanβ / Math.sqrt(1+tanβ*tanβ);\n        const cosβ = sinβ / tanβ;\n\n        // geodetic latitude (Bowring eqn.18: tanφ = z+ε²⋅b⋅sin³β / p−e²⋅cos³β)\n        const φ = isNaN(cosβ) ? 0 : Math.atan2(z + ε2*b*sinβ*sinβ*sinβ, p - e2*a*cosβ*cosβ*cosβ);\n\n        // longitude\n        const λ = Math.atan2(y, x);\n\n        // height above ellipsoid (Bowring eqn.7)\n        const sinφ = Math.sin(φ), cosφ = Math.cos(φ);\n        const ν = a / Math.sqrt(1-e2*sinφ*sinφ); // length of the normal terminated by the minor axis\n        const h = p*cosφ + z*sinφ - (a*a/ν);\n\n        const point = new LatLonEllipsoidal(φ.toDegrees(), λ.toDegrees(), h);\n\n        return point;\n    }\n\n\n    /**\n     * Returns a string representation of ‘this’ cartesian point.\n     *\n     * @param   {number} [dp=0] - Number of decimal places to use.\n     * @returns {string} Comma-separated latitude/longitude.\n     */\n    toString(dp=0) {\n        const x = this.x.toFixed(dp), y = this.y.toFixed(dp), z = this.z.toFixed(dp);\n        return `[${x},${y},${z}]`;\n    }\n\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nexport { LatLonEllipsoidal as default, Cartesian, Vector3d, Dms };\n", "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/* Geodesy tools for conversions between (historical) datums          (c) Chris Veness 2005-2019  */\n/*                                                                                   MIT Licence  */\n/* www.movable-type.co.uk/scripts/latlong-convert-coords.html                                     */\n/* www.movable-type.co.uk/scripts/geodesy-library.html#latlon-ellipsoidal-datum                  */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nimport LatLonEllipsoidal, { Cartesian, Dms } from './latlon-ellipsoidal.js';\n\n\n/**\n * Historical geodetic datums: a latitude/longitude point defines a geographic location on or\n * above/below the  earth’s surface, measured in degrees from the equator & the International\n * Reference Meridian and metres above the ellipsoid, and based on a given datum. The datum is\n * based on a reference ellipsoid and tied to geodetic survey reference points.\n *\n * Modern geodesy is generally based on the WGS84 datum (as used for instance by GPS systems), but\n * previously various reference ellipsoids and datum references were used.\n *\n * This module extends the core latlon-ellipsoidal module to include ellipsoid parameters and datum\n * transformation parameters, and methods for converting between different (generally historical)\n * datums.\n *\n * It can be used for UK Ordnance Survey mapping (OS National Grid References are still based on the\n * otherwise historical OSGB36 datum), as well as for historical purposes.\n *\n * q.v. Ordnance Survey ‘A guide to coordinate systems in Great Britain’ Section 6,\n * www.ordnancesurvey.co.uk/docs/support/guide-coordinate-systems-great-britain.pdf, and also\n * www.ordnancesurvey.co.uk/blog/2014/12/2.\n *\n * @module latlon-ellipsoidal-datum\n */\n\n\n/*\n * Ellipsoid parameters; exposed through static getter below.\n */\nconst ellipsoids = {\n    WGS84:         { a: 6378137,     b: 6356752.314245, f: 1/298.257223563 },\n    Airy1830:      { a: 6377563.396, b: 6356256.909,    f: 1/299.3249646   },\n    AiryModified:  { a: 6377340.189, b: 6356034.448,    f: 1/299.3249646   },\n    Bessel1841:    { a: 6377397.155, b: 6356078.962818, f: 1/299.1528128   },\n    Clarke1866:    { a: 6378206.4,   b: 6356583.8,      f: 1/294.978698214 },\n    Clarke1880IGN: { a: 6378249.2,   b: 6356515.0,      f: 1/293.466021294 },\n    GRS80:         { a: 6378137,     b: 6356752.314140, f: 1/298.257222101 },\n    Intl1924:      { a: 6378388,     b: 6356911.946,    f: 1/297           }, // aka Hayford\n    WGS72:         { a: 6378135,     b: 6356750.5,      f: 1/298.26        },\n};\n\n\n/*\n * Datums; exposed through static getter below.\n */\nconst datums = {\n    // transforms: t in metres, s in ppm, r in arcseconds              tx       ty        tz       s        rx        ry        rz\n    ED50:       { ellipsoid: ellipsoids.Intl1924,      transform: [   89.5,    93.8,    123.1,    -1.2,     0.0,      0.0,      0.156    ] }, // epsg.io/1311\n    ETRS89:     { ellipsoid: ellipsoids.GRS80,         transform: [    0,       0,        0,       0,       0,        0,        0        ] }, // epsg.io/1149; @ 1-metre level\n    Irl1975:    { ellipsoid: ellipsoids.AiryModified,  transform: [ -482.530, 130.596, -564.557,  -8.150,   1.042,    0.214,    0.631    ] }, // epsg.io/1954\n    NAD27:      { ellipsoid: ellipsoids.Clarke1866,    transform: [    8,    -160,     -176,       0,       0,        0,        0        ] },\n    NAD83:      { ellipsoid: ellipsoids.GRS80,         transform: [    0.9956, -1.9103,  -0.5215, -0.00062, 0.025915, 0.009426, 0.011599 ] },\n    NTF:        { ellipsoid: ellipsoids.Clarke1880IGN, transform: [  168,      60,     -320,       0,       0,        0,        0        ] },\n    OSGB36:     { ellipsoid: ellipsoids.Airy1830,      transform: [ -446.448, 125.157, -542.060,  20.4894, -0.1502,  -0.2470,  -0.8421   ] }, // epsg.io/1314\n    Potsdam:    { ellipsoid: ellipsoids.Bessel1841,    transform: [ -582,    -105,     -414,      -8.3,     1.04,     0.35,    -3.08     ] },\n    TokyoJapan: { ellipsoid: ellipsoids.Bessel1841,    transform: [  148,    -507,     -685,       0,       0,        0,        0        ] },\n    WGS72:      { ellipsoid: ellipsoids.WGS72,         transform: [    0,       0,       -4.5,    -0.22,    0,        0,        0.554    ] },\n    WGS84:      { ellipsoid: ellipsoids.WGS84,         transform: [    0.0,     0.0,      0.0,     0.0,     0.0,      0.0,      0.0      ] },\n};\n/* sources:\n * - ED50:       www.gov.uk/guidance/oil-and-gas-petroleum-operations-notices#pon-4\n * - Irl1975:    www.osi.ie/wp-content/uploads/2015/05/transformations_booklet.pdf\n * - NAD27:      en.wikipedia.org/wiki/Helmert_transformation\n * - NAD83:      www.uvm.edu/giv/resources/WGS84_NAD83.pdf [strictly, WGS84(G1150) -> NAD83(CORS96) @ epoch 1997.0]\n *               (note NAD83(1986) ≡ WGS84(Original); confluence.qps.nl/pages/viewpage.action?pageId=29855173)\n * - NTF:        Nouvelle Triangulation Francaise geodesie.ign.fr/contenu/fichiers/Changement_systeme_geodesique.pdf\n * - OSGB36:     www.ordnancesurvey.co.uk/docs/support/guide-coordinate-systems-great-britain.pdf\n * - Potsdam:    kartoweb.itc.nl/geometrics/Coordinate%20transformations/coordtrans.html\n * - TokyoJapan: www.geocachingtoolbox.com?page=datumEllipsoidDetails\n * - WGS72:      www.icao.int/safety/pbn/documentation/eurocontrol/eurocontrol wgs 84 implementation manual.pdf\n *\n * more transform parameters are available from earth-info.nga.mil/GandG/coordsys/datums/NATO_DT.pdf,\n * www.fieldenmaps.info/cconv/web/cconv_params.js\n */\n/* note:\n * - ETRS89 reference frames are coincident with WGS-84 at epoch 1989.0 (ie null transform) at the one metre level.\n */\n\n\n// freeze static properties\nObject.keys(ellipsoids).forEach(e => Object.freeze(ellipsoids[e]));\nObject.keys(datums).forEach(d => { Object.freeze(datums[d]); Object.freeze(datums[d].transform); });\n\n\n/* LatLon - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n\n/**\n * Latitude/longitude points on an ellipsoidal model earth, with ellipsoid parameters and methods\n * for converting between datums and to geocentric (ECEF) cartesian coordinates.\n *\n * @extends LatLonEllipsoidal\n */\nclass LatLonEllipsoidal_Datum extends LatLonEllipsoidal {\n\n    /**\n     * Creates a geodetic latitude/longitude point on an ellipsoidal model earth using given datum.\n     *\n     * @param {number} lat - Latitude (in degrees).\n     * @param {number} lon - Longitude (in degrees).\n     * @param {number} [height=0] - Height above ellipsoid in metres.\n     * @param {LatLon.datums} datum - Datum this point is defined within.\n     *\n     * @example\n     *   import LatLon from '/js/geodesy/latlon-ellipsoidal-datum.js';\n     *   const p = new LatLon(53.3444, -6.2577, 17, LatLon.datums.Irl1975);\n     */\n    constructor(lat, lon, height=0, datum=datums.WGS84) {\n        if (!datum || datum.ellipsoid==undefined) throw new TypeError(`unrecognised datum ‘${datum}’`);\n\n        super(lat, lon, height);\n\n        this._datum = datum;\n    }\n\n\n    /**\n     * Datum this point is defined within.\n     */\n    get datum() {\n        return this._datum;\n    }\n\n\n    /**\n     * Ellipsoids with their parameters; semi-major axis (a), semi-minor axis (b), and flattening (f).\n     *\n     * Flattening f = (a−b)/a; at least one of these parameters is derived from defining constants.\n     *\n     * @example\n     *   const a = LatLon.ellipsoids.Airy1830.a; // 6377563.396\n     */\n    static get ellipsoids() {\n        return ellipsoids;\n    }\n\n\n    /**\n     * Datums; with associated ellipsoid, and Helmert transform parameters to convert from WGS-84\n     * into given datum.\n     *\n     * Note that precision of various datums will vary, and WGS-84 (original) is not defined to be\n     * accurate to better than ±1 metre. No transformation should be assumed to be accurate to\n     * better than a metre, for many datums somewhat less.\n     *\n     * This is a small sample of commoner datums from a large set of historical datums. I will add\n     * new datums on request.\n     *\n     * @example\n     *   const a = LatLon.datums.OSGB36.ellipsoid.a;                    // 6377563.396\n     *   const tx = LatLon.datums.OSGB36.transform;                     // [ tx, ty, tz, s, rx, ry, rz ]\n     *   const availableDatums = Object.keys(LatLon.datums).join(', '); // ED50, Irl1975, NAD27, ...\n     */\n    static get datums() {\n        return datums;\n    }\n\n\n    // note instance datum getter/setters are in LatLonEllipsoidal\n\n\n    /**\n     * Parses a latitude/longitude point from a variety of formats.\n     *\n     * Latitude & longitude (in degrees) can be supplied as two separate parameters, as a single\n     * comma-separated lat/lon string, or as a single object with { lat, lon } or GeoJSON properties.\n     *\n     * The latitude/longitude values may be numeric or strings; they may be signed decimal or\n     * deg-min-sec (hexagesimal) suffixed by compass direction (NSEW); a variety of separators are\n     * accepted. Examples -3.62, '3 37 12W', '3°37′12″W'.\n     *\n     * Thousands/decimal separators must be comma/dot; use Dms.fromLocale to convert locale-specific\n     * thousands/decimal separators.\n     *\n     * @param   {number|string|Object} lat|latlon - Geodetic Latitude (in degrees) or comma-separated lat/lon or lat/lon object.\n     * @param   {number}               [lon] - Longitude in degrees.\n     * @param   {number}               [height=0] - Height above ellipsoid in metres.\n     * @param   {LatLon.datums}        [datum=WGS84] - Datum this point is defined within.\n     * @returns {LatLon} Latitude/longitude point on ellipsoidal model earth using given datum.\n     * @throws  {TypeError} Unrecognised datum.\n     *\n     * @example\n     *   const p = LatLon.parse('51.47736, 0.0000', 0, LatLon.datums.OSGB36);\n     */\n    static parse(...args) {\n        let datum = datums.WGS84;\n\n        // if the last argument is a datum, use that, otherwise use default WGS-84\n        if (args.length==4 || (args.length==3 && typeof args[2] == 'object')) datum = args.pop();\n\n        if (!datum || datum.ellipsoid==undefined) throw new TypeError(`unrecognised datum ‘${datum}’`);\n\n        const point = super.parse(...args);\n\n        point._datum = datum;\n\n        return point;\n    }\n\n\n    /**\n     * Converts ‘this’ lat/lon coordinate to new coordinate system.\n     *\n     * @param   {LatLon.datums} toDatum - Datum this coordinate is to be converted to.\n     * @returns {LatLon} This point converted to new datum.\n     * @throws  {TypeError} Unrecognised datum.\n     *\n     * @example\n     *   const pWGS84 = new LatLon(51.47788, -0.00147, 0, LatLon.datums.WGS84);\n     *   const pOSGB = pWGS84.convertDatum(LatLon.datums.OSGB36); // 51.4773°N, 000.0001°E\n     */\n    convertDatum(toDatum) {\n        if (!toDatum || toDatum.ellipsoid==undefined) throw new TypeError(`unrecognised datum ‘${toDatum}’`);\n\n        const oldCartesian = this.toCartesian();                 // convert geodetic to cartesian\n        const newCartesian = oldCartesian.convertDatum(toDatum); // convert datum\n        const newLatLon = newCartesian.toLatLon();               // convert cartesian back to geodetic\n\n        return newLatLon;\n    }\n\n\n    /**\n     * Converts ‘this’ point from (geodetic) latitude/longitude coordinates to (geocentric) cartesian\n     * (x/y/z) coordinates, based on the same datum.\n     *\n     * Shadow of LatLonEllipsoidal.toCartesian(), returning Cartesian augmented with\n     * LatLonEllipsoidal_Datum methods/properties.\n     *\n     * @returns {Cartesian} Cartesian point equivalent to lat/lon point, with x, y, z in metres from\n     *   earth centre, augmented with reference frame conversion methods and properties.\n     */\n    toCartesian() {\n        const cartesian = super.toCartesian();\n        const cartesianDatum = new Cartesian_Datum(cartesian.x, cartesian.y, cartesian.z, this.datum);\n        return cartesianDatum;\n    }\n\n}\n\n\n/* Cartesian  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n\n/**\n * Augments Cartesian with datum the cooordinate is based on, and methods to convert between datums\n * (using Helmert 7-parameter transforms) and to convert cartesian to geodetic latitude/longitude\n * point.\n *\n * @extends Cartesian\n */\nclass Cartesian_Datum extends Cartesian {\n\n    /**\n     * Creates cartesian coordinate representing ECEF (earth-centric earth-fixed) point, on a given\n     * datum. The datum will identify the primary meridian (for the x-coordinate), and is also\n     * useful in transforming to/from geodetic (lat/lon) coordinates.\n     *\n     * @param  {number} x - X coordinate in metres (=> 0°N,0°E).\n     * @param  {number} y - Y coordinate in metres (=> 0°N,90°E).\n     * @param  {number} z - Z coordinate in metres (=> 90°N).\n     * @param  {LatLon.datums} [datum] - Datum this coordinate is defined within.\n     * @throws {TypeError} Unrecognised datum.\n     *\n     * @example\n     *   import { Cartesian } from '/js/geodesy/latlon-ellipsoidal-datum.js';\n     *   const coord = new Cartesian(3980581.210, -111.159, 4966824.522);\n     */\n    constructor(x, y, z, datum=undefined) {\n        if (datum && datum.ellipsoid==undefined) throw new TypeError(`unrecognised datum ‘${datum}’`);\n\n        super(x, y, z);\n\n        if (datum) this._datum = datum;\n    }\n\n\n    /**\n     * Datum this point is defined within.\n     */\n    get datum() {\n        return this._datum;\n    }\n    set datum(datum) {\n        if (!datum || datum.ellipsoid==undefined) throw new TypeError(`unrecognised datum ‘${datum}’`);\n        this._datum = datum;\n    }\n\n\n    /**\n     * Converts ‘this’ (geocentric) cartesian (x/y/z) coordinate to (geodetic) latitude/longitude\n     * point (based on the same datum, or WGS84 if unset).\n     *\n     * Shadow of Cartesian.toLatLon(), returning LatLon augmented with LatLonEllipsoidal_Datum\n     * methods convertDatum, toCartesian, etc.\n     *\n     * @returns {LatLon} Latitude/longitude point defined by cartesian coordinates.\n     * @throws  {TypeError} Unrecognised datum\n     *\n     * @example\n     *   const c = new Cartesian(4027893.924, 307041.993, 4919474.294);\n     *   const p = c.toLatLon(); // 50.7978°N, 004.3592°E\n     */\n    toLatLon(deprecatedDatum=undefined) {\n        if (deprecatedDatum) {\n            console.info('datum parameter to Cartesian_Datum.toLatLon is deprecated: set datum before calling toLatLon()');\n            this.datum = deprecatedDatum;\n        }\n        const datum = this.datum || datums.WGS84;\n        if (!datum || datum.ellipsoid==undefined) throw new TypeError(`unrecognised datum ‘${datum}’`);\n\n        const latLon = super.toLatLon(datum.ellipsoid); // TODO: what if datum is not geocentric?\n        const point = new LatLonEllipsoidal_Datum(latLon.lat, latLon.lon, latLon.height, this.datum);\n        return point;\n    }\n\n\n    /**\n     * Converts ‘this’ cartesian coordinate to new datum using Helmert 7-parameter transformation.\n     *\n     * @param   {LatLon.datums} toDatum - Datum this coordinate is to be converted to.\n     * @returns {Cartesian} This point converted to new datum.\n     * @throws  {Error} Undefined datum.\n     *\n     * @example\n     *   const c = new Cartesian(3980574.247, -102.127, 4966830.065, LatLon.datums.OSGB36);\n     *   c.convertDatum(LatLon.datums.Irl1975); // [??,??,??]\n     */\n    convertDatum(toDatum) {\n        // TODO: what if datum is not geocentric?\n        if (!toDatum || toDatum.ellipsoid == undefined) throw new TypeError(`unrecognised datum ‘${toDatum}’`);\n        if (!this.datum) throw new TypeError('cartesian coordinate has no datum');\n\n        let oldCartesian = null;\n        let transform = null;\n\n        if (this.datum == undefined || this.datum == datums.WGS84) {\n            // converting from WGS 84\n            oldCartesian = this;\n            transform = toDatum.transform;\n        }\n        if (toDatum == datums.WGS84) {\n            // converting to WGS 84; use inverse transform\n            oldCartesian = this;\n            transform = this.datum.transform.map(p => -p);\n        }\n        if (transform == null) {\n            // neither this.datum nor toDatum are WGS84: convert this to WGS84 first\n            oldCartesian = this.convertDatum(datums.WGS84);\n            transform = toDatum.transform;\n        }\n\n        const newCartesian = oldCartesian.applyTransform(transform);\n        newCartesian.datum = toDatum;\n\n        return newCartesian;\n    }\n\n\n    /**\n     * Applies Helmert 7-parameter transformation to ‘this’ coordinate using transform parameters t.\n     *\n     * This is used in converting datums (geodetic->cartesian, apply transform, cartesian->geodetic).\n     *\n     * @private\n     * @param   {number[]} t - Transformation to apply to this coordinate.\n     * @returns {Cartesian} Transformed point.\n     */\n    applyTransform(t)   {\n        // this point\n        const { x: x1, y: y1, z: z1 } = this;\n\n        // transform parameters\n        const tx = t[0];                    // x-shift in metres\n        const ty = t[1];                    // y-shift in metres\n        const tz = t[2];                    // z-shift in metres\n        const s  = t[3]/1e6 + 1;            // scale: normalise parts-per-million to (s+1)\n        const rx = (t[4]/3600).toRadians(); // x-rotation: normalise arcseconds to radians\n        const ry = (t[5]/3600).toRadians(); // y-rotation: normalise arcseconds to radians\n        const rz = (t[6]/3600).toRadians(); // z-rotation: normalise arcseconds to radians\n\n        // apply transform\n        const x2 = tx + x1*s  - y1*rz + z1*ry;\n        const y2 = ty + x1*rz + y1*s  - z1*rx;\n        const z2 = tz - x1*ry + y1*rx + z1*s;\n\n        return new Cartesian_Datum(x2, y2, z2);\n    }\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nexport { LatLonEllipsoidal_Datum as default, Cartesian_Datum as Cartesian, datums, Dms };\n"],
  "mappings": "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",
  "names": ["lat", "lon", "ellipsoids", "datums"]
}
