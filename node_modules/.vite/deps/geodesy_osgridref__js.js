import {
  LatLonEllipsoidal_Datum
} from "./chunk-NPAZ35PB.js";
import {
  dms_default
} from "./chunk-GIFWOSH2.js";

// node_modules/geodesy/osgridref.js
var nationalGrid = {
  trueOrigin: { lat: 49, lon: -2 },
  // true origin of grid 49°N,2°W on OSGB36 datum
  falseOrigin: { easting: -4e5, northing: 1e5 },
  // easting & northing of false origin, metres from true origin
  scaleFactor: 0.9996012717,
  // scale factor on central meridian
  ellipsoid: LatLonEllipsoidal_Datum.ellipsoids.Airy1830
};
var OsGridRef = class _OsGridRef {
  /**
   * Creates an OsGridRef object.
   *
   * @param {number} easting - Easting in metres from OS Grid false origin.
   * @param {number} northing - Northing in metres from OS Grid false origin.
   *
   * @example
   *   import OsGridRef from '/js/geodesy/osgridref.js';
   *   const gridref = new OsGridRef(651409, 313177);
   */
  constructor(easting, northing) {
    this.easting = Number(easting);
    this.northing = Number(northing);
    if (isNaN(easting) || this.easting < 0 || this.easting > 7e5)
      throw new RangeError(`invalid easting ‘${easting}’`);
    if (isNaN(northing) || this.northing < 0 || this.northing > 13e5)
      throw new RangeError(`invalid northing ‘${northing}’`);
  }
  /**
   * Converts ‘this’ Ordnance Survey Grid Reference easting/northing coordinate to latitude/longitude
   * (SW corner of grid square).
   *
   * While OS Grid References are based on OSGB-36, the Ordnance Survey have deprecated the use of
   * OSGB-36 for latitude/longitude coordinates (in favour of WGS-84), hence this function returns
   * WGS-84 by default, with OSGB-36 as an option. See www.ordnancesurvey.co.uk/blog/2014/12/2.
   *
   * Note formulation implemented here due to Thomas, Redfearn, etc is as published by OS, but is
   * inferior to Krüger as used by e.g. Karney 2011.
   *
   * @param   {LatLon.datum} [datum=WGS84] - Datum to convert grid reference into.
   * @returns {LatLon}       Latitude/longitude of supplied grid reference.
   *
   * @example
   *   const gridref = new OsGridRef(651409.903, 313177.270);
   *   const pWgs84 = gridref.toLatLon();                    // 52°39′28.723″N, 001°42′57.787″E
   *   // to obtain (historical) OSGB36 lat/lon point:
   *   const pOsgb = gridref.toLatLon(LatLon.datums.OSGB36); // 52°39′27.253″N, 001°43′04.518″E
   */
  toLatLon(datum = LatLonEllipsoidal_Datum.datums.WGS84) {
    const { easting: E, northing: N } = this;
    const { a, b } = nationalGrid.ellipsoid;
    const φ0 = nationalGrid.trueOrigin.lat.toRadians();
    const λ0 = nationalGrid.trueOrigin.lon.toRadians();
    const E0 = -nationalGrid.falseOrigin.easting;
    const N0 = -nationalGrid.falseOrigin.northing;
    const F0 = nationalGrid.scaleFactor;
    const e2 = 1 - b * b / (a * a);
    const n = (a - b) / (a + b), n2 = n * n, n3 = n * n * n;
    let φ = φ0, M = 0;
    do {
      φ = (N - N0 - M) / (a * F0) + φ;
      const Ma = (1 + n + 5 / 4 * n2 + 5 / 4 * n3) * (φ - φ0);
      const Mb = (3 * n + 3 * n * n + 21 / 8 * n3) * Math.sin(φ - φ0) * Math.cos(φ + φ0);
      const Mc = (15 / 8 * n2 + 15 / 8 * n3) * Math.sin(2 * (φ - φ0)) * Math.cos(2 * (φ + φ0));
      const Md = 35 / 24 * n3 * Math.sin(3 * (φ - φ0)) * Math.cos(3 * (φ + φ0));
      M = b * F0 * (Ma - Mb + Mc - Md);
    } while (Math.abs(N - N0 - M) >= 1e-5);
    const cosφ = Math.cos(φ), sinφ = Math.sin(φ);
    const ν = a * F0 / Math.sqrt(1 - e2 * sinφ * sinφ);
    const ρ = a * F0 * (1 - e2) / Math.pow(1 - e2 * sinφ * sinφ, 1.5);
    const η2 = ν / ρ - 1;
    const tanφ = Math.tan(φ);
    const tan2φ = tanφ * tanφ, tan4φ = tan2φ * tan2φ, tan6φ = tan4φ * tan2φ;
    const secφ = 1 / cosφ;
    const ν3 = ν * ν * ν, ν5 = ν3 * ν * ν, ν7 = ν5 * ν * ν;
    const VII = tanφ / (2 * ρ * ν);
    const VIII = tanφ / (24 * ρ * ν3) * (5 + 3 * tan2φ + η2 - 9 * tan2φ * η2);
    const IX = tanφ / (720 * ρ * ν5) * (61 + 90 * tan2φ + 45 * tan4φ);
    const X = secφ / ν;
    const XI = secφ / (6 * ν3) * (ν / ρ + 2 * tan2φ);
    const XII = secφ / (120 * ν5) * (5 + 28 * tan2φ + 24 * tan4φ);
    const XIIA = secφ / (5040 * ν7) * (61 + 662 * tan2φ + 1320 * tan4φ + 720 * tan6φ);
    const dE = E - E0, dE2 = dE * dE, dE3 = dE2 * dE, dE4 = dE2 * dE2, dE5 = dE3 * dE2, dE6 = dE4 * dE2, dE7 = dE5 * dE2;
    φ = φ - VII * dE2 + VIII * dE4 - IX * dE6;
    const λ = λ0 + X * dE - XI * dE3 + XII * dE5 - XIIA * dE7;
    let point = new LatLon_OsGridRef(φ.toDegrees(), λ.toDegrees(), 0, LatLonEllipsoidal_Datum.datums.OSGB36);
    if (datum != LatLonEllipsoidal_Datum.datums.OSGB36) {
      point = point.convertDatum(datum);
      point = new LatLon_OsGridRef(point.lat, point.lon, point.height, point.datum);
    }
    return point;
  }
  /**
   * Parses grid reference to OsGridRef object.
   *
   * Accepts standard grid references (eg 'SU 387 148'), with or without whitespace separators, from
   * two-digit references up to 10-digit references (1m × 1m square), or fully numeric comma-separated
   * references in metres (eg '438700,114800').
   *
   * @param   {string}    gridref - Standard format OS Grid Reference.
   * @returns {OsGridRef} Numeric version of grid reference in metres from false origin (SW corner of
   *   supplied grid square).
   * @throws  {Error}     Invalid grid reference.
   *
   * @example
   *   const grid = OsGridRef.parse('TG 51409 13177'); // grid: { easting: 651409, northing: 313177 }
   */
  static parse(gridref) {
    gridref = String(gridref).trim();
    let match = gridref.match(/^(\d+),\s*(\d+)$/);
    if (match)
      return new _OsGridRef(match[1], match[2]);
    match = gridref.match(/^[HNST][ABCDEFGHJKLMNOPQRSTUVWXYZ]\s*[0-9]+\s*[0-9]+$/i);
    if (!match)
      throw new Error(`invalid grid reference ‘${gridref}’`);
    let l1 = gridref.toUpperCase().charCodeAt(0) - "A".charCodeAt(0);
    let l2 = gridref.toUpperCase().charCodeAt(1) - "A".charCodeAt(0);
    if (l1 > 7)
      l1--;
    if (l2 > 7)
      l2--;
    const e100km = (l1 - 2) % 5 * 5 + l2 % 5;
    const n100km = 19 - Math.floor(l1 / 5) * 5 - Math.floor(l2 / 5);
    let en = gridref.slice(2).trim().split(/\s+/);
    if (en.length == 1)
      en = [en[0].slice(0, en[0].length / 2), en[0].slice(en[0].length / 2)];
    if (en[0].length != en[1].length)
      throw new Error(`invalid grid reference ‘${gridref}’`);
    en[0] = en[0].padEnd(5, "0");
    en[1] = en[1].padEnd(5, "0");
    const e = e100km + en[0];
    const n = n100km + en[1];
    return new _OsGridRef(e, n);
  }
  /**
   * Converts ‘this’ numeric grid reference to standard OS Grid Reference.
   *
   * @param   {number} [digits=10] - Precision of returned grid reference (10 digits = metres);
   *   digits=0 will return grid reference in numeric format.
   * @returns {string} This grid reference in standard format.
   *
   * @example
   *   const gridref = new OsGridRef(651409, 313177).toString(8); // 'TG 5140 1317'
   *   const gridref = new OsGridRef(651409, 313177).toString(0); // '651409,313177'
   */
  toString(digits = 10) {
    if (![0, 2, 4, 6, 8, 10, 12, 14, 16].includes(Number(digits)))
      throw new RangeError(`invalid precision ‘${digits}’`);
    let { easting: e, northing: n } = this;
    if (digits == 0) {
      const format = { useGrouping: false, minimumIntegerDigits: 6, maximumFractionDigits: 3 };
      const ePad = e.toLocaleString("en", format);
      const nPad = n.toLocaleString("en", format);
      return `${ePad},${nPad}`;
    }
    const e100km = Math.floor(e / 1e5), n100km = Math.floor(n / 1e5);
    let l1 = 19 - n100km - (19 - n100km) % 5 + Math.floor((e100km + 10) / 5);
    let l2 = (19 - n100km) * 5 % 25 + e100km % 5;
    if (l1 > 7)
      l1++;
    if (l2 > 7)
      l2++;
    const letterPair = String.fromCharCode(l1 + "A".charCodeAt(0), l2 + "A".charCodeAt(0));
    e = Math.floor(e % 1e5 / Math.pow(10, 5 - digits / 2));
    n = Math.floor(n % 1e5 / Math.pow(10, 5 - digits / 2));
    e = e.toString().padStart(digits / 2, "0");
    n = n.toString().padStart(digits / 2, "0");
    return `${letterPair} ${e} ${n}`;
  }
};
var LatLon_OsGridRef = class _LatLon_OsGridRef extends LatLonEllipsoidal_Datum {
  /**
   * Converts latitude/longitude to Ordnance Survey grid reference easting/northing coordinate.
   *
   * @returns {OsGridRef} OS Grid Reference easting/northing.
   *
   * @example
   *   const grid = new LatLon(52.65798, 1.71605).toOsGrid(); // TG 51409 13177
   *   // for conversion of (historical) OSGB36 latitude/longitude point:
   *   const grid = new LatLon(52.65798, 1.71605).toOsGrid(LatLon.datums.OSGB36);
   */
  toOsGrid() {
    const point = this.datum == LatLonEllipsoidal_Datum.datums.OSGB36 ? this : this.convertDatum(LatLonEllipsoidal_Datum.datums.OSGB36);
    const φ = point.lat.toRadians();
    const λ = point.lon.toRadians();
    const { a, b } = nationalGrid.ellipsoid;
    const φ0 = nationalGrid.trueOrigin.lat.toRadians();
    const λ0 = nationalGrid.trueOrigin.lon.toRadians();
    const E0 = -nationalGrid.falseOrigin.easting;
    const N0 = -nationalGrid.falseOrigin.northing;
    const F0 = nationalGrid.scaleFactor;
    const e2 = 1 - b * b / (a * a);
    const n = (a - b) / (a + b), n2 = n * n, n3 = n * n * n;
    const cosφ = Math.cos(φ), sinφ = Math.sin(φ);
    const ν = a * F0 / Math.sqrt(1 - e2 * sinφ * sinφ);
    const ρ = a * F0 * (1 - e2) / Math.pow(1 - e2 * sinφ * sinφ, 1.5);
    const η2 = ν / ρ - 1;
    const Ma = (1 + n + 5 / 4 * n2 + 5 / 4 * n3) * (φ - φ0);
    const Mb = (3 * n + 3 * n * n + 21 / 8 * n3) * Math.sin(φ - φ0) * Math.cos(φ + φ0);
    const Mc = (15 / 8 * n2 + 15 / 8 * n3) * Math.sin(2 * (φ - φ0)) * Math.cos(2 * (φ + φ0));
    const Md = 35 / 24 * n3 * Math.sin(3 * (φ - φ0)) * Math.cos(3 * (φ + φ0));
    const M = b * F0 * (Ma - Mb + Mc - Md);
    const cos3φ = cosφ * cosφ * cosφ;
    const cos5φ = cos3φ * cosφ * cosφ;
    const tan2φ = Math.tan(φ) * Math.tan(φ);
    const tan4φ = tan2φ * tan2φ;
    const I = M + N0;
    const II = ν / 2 * sinφ * cosφ;
    const III = ν / 24 * sinφ * cos3φ * (5 - tan2φ + 9 * η2);
    const IIIA = ν / 720 * sinφ * cos5φ * (61 - 58 * tan2φ + tan4φ);
    const IV = ν * cosφ;
    const V = ν / 6 * cos3φ * (ν / ρ - tan2φ);
    const VI = ν / 120 * cos5φ * (5 - 18 * tan2φ + tan4φ + 14 * η2 - 58 * tan2φ * η2);
    const Δλ = λ - λ0;
    const Δλ2 = Δλ * Δλ, Δλ3 = Δλ2 * Δλ, Δλ4 = Δλ3 * Δλ, Δλ5 = Δλ4 * Δλ, Δλ6 = Δλ5 * Δλ;
    let N = I + II * Δλ2 + III * Δλ4 + IIIA * Δλ6;
    let E = E0 + IV * Δλ + V * Δλ3 + VI * Δλ5;
    N = Number(N.toFixed(3));
    E = Number(E.toFixed(3));
    try {
      return new OsGridRef(E, N);
    } catch (e) {
      throw new Error(`${e.message} from (${point.lat.toFixed(6)},${point.lon.toFixed(6)}).toOsGrid()`);
    }
  }
  /**
   * Override LatLonEllipsoidal.convertDatum() with version which returns LatLon_OsGridRef.
   */
  convertDatum(toDatum) {
    const osgbED = super.convertDatum(toDatum);
    const osgbOSGR = new _LatLon_OsGridRef(osgbED.lat, osgbED.lon, osgbED.height, osgbED.datum);
    return osgbOSGR;
  }
};
export {
  dms_default as Dms,
  LatLon_OsGridRef as LatLon,
  OsGridRef as default
};
//# sourceMappingURL=geodesy_osgridref__js.js.map
