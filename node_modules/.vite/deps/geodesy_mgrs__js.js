import {
  LatLonEllipsoidal_Datum
} from "./chunk-NPAZ35PB.js";
import {
  dms_default
} from "./chunk-GIFWOSH2.js";

// node_modules/geodesy/utm.js
var Utm = class {
  /**
   * Creates a Utm coordinate object comprising zone, hemisphere, easting, northing on a given
   * datum (normally WGS84).
   *
   * @param  {number}        zone - UTM 6° longitudinal zone (1..60 covering 180°W..180°E).
   * @param  {string}        hemisphere - N for northern hemisphere, S for southern hemisphere.
   * @param  {number}        easting - Easting in metres from false easting (-500km from central meridian).
   * @param  {number}        northing - Northing in metres from equator (N) or from false northing -10,000km (S).
   * @param  {LatLon.datums} [datum=WGS84] - Datum UTM coordinate is based on.
   * @param  {number}        [convergence=null] - Meridian convergence (bearing of grid north
   *                         clockwise from true north), in degrees.
   * @param  {number}        [scale=null] - Grid scale factor.
   * @params {boolean=true}  verifyEN - Check easting/northing is within 'normal' values (may be
   *                         suppressed for extended coherent coordinates or alternative datums
   *                         e.g. ED50 (epsg.io/23029).
   * @throws {TypeError} Invalid UTM coordinate.
   *
   * @example
   *   import Utm from '/js/geodesy/utm.js';
   *   const utmCoord = new Utm(31, 'N', 448251, 5411932);
   */
  constructor(zone, hemisphere, easting, northing, datum = LatLonEllipsoidal_Datum.datums.WGS84, convergence = null, scale = null, verifyEN = true) {
    if (!(1 <= zone && zone <= 60))
      throw new RangeError(`invalid UTM zone ‘${zone}’`);
    if (zone != parseInt(zone))
      throw new RangeError(`invalid UTM zone ‘${zone}’`);
    if (typeof hemisphere != "string" || !hemisphere.match(/[NS]/i))
      throw new RangeError(`invalid UTM hemisphere ‘${hemisphere}’`);
    if (verifyEN) {
      if (!(0 <= easting && easting <= 1e6))
        throw new RangeError(`invalid UTM easting ‘${easting}’`);
      if (hemisphere.toUpperCase() == "N" && !(0 <= northing && northing < 9328094))
        throw new RangeError(`invalid UTM northing ‘${northing}’`);
      if (hemisphere.toUpperCase() == "S" && !(1118414 < northing && northing <= 1e7))
        throw new RangeError(`invalid UTM northing ‘${northing}’`);
    }
    if (!datum || datum.ellipsoid == void 0)
      throw new TypeError(`unrecognised datum ‘${datum}’`);
    this.zone = Number(zone);
    this.hemisphere = hemisphere.toUpperCase();
    this.easting = Number(easting);
    this.northing = Number(northing);
    this.datum = datum;
    this.convergence = convergence === null ? null : Number(convergence);
    this.scale = scale === null ? null : Number(scale);
  }
  /**
   * Converts UTM zone/easting/northing coordinate to latitude/longitude.
   *
   * Implements Karney’s method, using Krüger series to order n⁶, giving results accurate to 5nm
   * for distances up to 3900km from the central meridian.
   *
   * @param   {Utm} utmCoord - UTM coordinate to be converted to latitude/longitude.
   * @returns {LatLon} Latitude/longitude of supplied grid reference.
   *
   * @example
   *   const grid = new Utm(31, 'N', 448251.795, 5411932.678);
   *   const latlong = grid.toLatLon(); // 48°51′29.52″N, 002°17′40.20″E
   */
  toLatLon() {
    const { zone: z, hemisphere: h } = this;
    const falseEasting = 5e5, falseNorthing = 1e7;
    const { a, f } = this.datum.ellipsoid;
    const k0 = 0.9996;
    const x = this.easting - falseEasting;
    const y = h == "S" ? this.northing - falseNorthing : this.northing;
    const e = Math.sqrt(f * (2 - f));
    const n = f / (2 - f);
    const n2 = n * n, n3 = n * n2, n4 = n * n3, n5 = n * n4, n6 = n * n5;
    const A = a / (1 + n) * (1 + 1 / 4 * n2 + 1 / 64 * n4 + 1 / 256 * n6);
    const η = x / (k0 * A);
    const ξ = y / (k0 * A);
    const β = [
      null,
      // note β is one-based array (6th order Krüger expressions)
      1 / 2 * n - 2 / 3 * n2 + 37 / 96 * n3 - 1 / 360 * n4 - 81 / 512 * n5 + 96199 / 604800 * n6,
      1 / 48 * n2 + 1 / 15 * n3 - 437 / 1440 * n4 + 46 / 105 * n5 - 1118711 / 3870720 * n6,
      17 / 480 * n3 - 37 / 840 * n4 - 209 / 4480 * n5 + 5569 / 90720 * n6,
      4397 / 161280 * n4 - 11 / 504 * n5 - 830251 / 7257600 * n6,
      4583 / 161280 * n5 - 108847 / 3991680 * n6,
      20648693 / 638668800 * n6
    ];
    let ξʹ = ξ;
    for (let j = 1; j <= 6; j++)
      ξʹ -= β[j] * Math.sin(2 * j * ξ) * Math.cosh(2 * j * η);
    let ηʹ = η;
    for (let j = 1; j <= 6; j++)
      ηʹ -= β[j] * Math.cos(2 * j * ξ) * Math.sinh(2 * j * η);
    const sinhηʹ = Math.sinh(ηʹ);
    const sinξʹ = Math.sin(ξʹ), cosξʹ = Math.cos(ξʹ);
    const τʹ = sinξʹ / Math.sqrt(sinhηʹ * sinhηʹ + cosξʹ * cosξʹ);
    let δτi = null;
    let τi = τʹ;
    do {
      const σi = Math.sinh(e * Math.atanh(e * τi / Math.sqrt(1 + τi * τi)));
      const τiʹ = τi * Math.sqrt(1 + σi * σi) - σi * Math.sqrt(1 + τi * τi);
      δτi = (τʹ - τiʹ) / Math.sqrt(1 + τiʹ * τiʹ) * (1 + (1 - e * e) * τi * τi) / ((1 - e * e) * Math.sqrt(1 + τi * τi));
      τi += δτi;
    } while (Math.abs(δτi) > 1e-12);
    const τ = τi;
    const φ = Math.atan(τ);
    let λ = Math.atan2(sinhηʹ, cosξʹ);
    let p = 1;
    for (let j = 1; j <= 6; j++)
      p -= 2 * j * β[j] * Math.cos(2 * j * ξ) * Math.cosh(2 * j * η);
    let q = 0;
    for (let j = 1; j <= 6; j++)
      q += 2 * j * β[j] * Math.sin(2 * j * ξ) * Math.sinh(2 * j * η);
    const γʹ = Math.atan(Math.tan(ξʹ) * Math.tanh(ηʹ));
    const γʺ = Math.atan2(q, p);
    const γ = γʹ + γʺ;
    const sinφ = Math.sin(φ);
    const kʹ = Math.sqrt(1 - e * e * sinφ * sinφ) * Math.sqrt(1 + τ * τ) * Math.sqrt(sinhηʹ * sinhηʹ + cosξʹ * cosξʹ);
    const kʺ = A / a / Math.sqrt(p * p + q * q);
    const k = k0 * kʹ * kʺ;
    const λ0 = ((z - 1) * 6 - 180 + 3).toRadians();
    λ += λ0;
    const lat = Number(φ.toDegrees().toFixed(14));
    const lon = Number(λ.toDegrees().toFixed(14));
    const convergence = Number(γ.toDegrees().toFixed(9));
    const scale = Number(k.toFixed(12));
    const latLong = new LatLon_Utm(lat, lon, 0, this.datum);
    latLong.convergence = convergence;
    latLong.scale = scale;
    return latLong;
  }
  /**
   * Parses string representation of UTM coordinate.
   *
   * A UTM coordinate comprises (space-separated)
   *  - zone
   *  - hemisphere
   *  - easting
   *  - northing.
   *
   * @param   {string} utmCoord - UTM coordinate (WGS 84).
   * @param   {Datum}  [datum=WGS84] - Datum coordinate is defined in (default WGS 84).
   * @returns {Utm} Parsed UTM coordinate.
   * @throws  {TypeError} Invalid UTM coordinate.
   *
   * @example
   *   const utmCoord = Utm.parse('31 N 448251 5411932');
   *   // utmCoord: {zone: 31, hemisphere: 'N', easting: 448251, northing: 5411932 }
   */
  static parse(utmCoord, datum = LatLonEllipsoidal_Datum.datums.WGS84) {
    utmCoord = utmCoord.trim().match(/\S+/g);
    if (utmCoord == null || utmCoord.length != 4)
      throw new Error(`invalid UTM coordinate ‘${utmCoord}’`);
    const zone = utmCoord[0], hemisphere = utmCoord[1], easting = utmCoord[2], northing = utmCoord[3];
    return new this(zone, hemisphere, easting, northing, datum);
  }
  /**
   * Returns a string representation of a UTM coordinate.
   *
   * To distinguish from MGRS grid zone designators, a space is left between the zone and the
   * hemisphere.
   *
   * Note that UTM coordinates get rounded, not truncated (unlike MGRS grid references).
   *
   * @param   {number} [digits=0] - Number of digits to appear after the decimal point (3 ≡ mm).
   * @returns {string} A string representation of the coordinate.
   *
   * @example
   *   const utm = new Utm('31', 'N', 448251, 5411932).toString(4);  // 31 N 448251.0000 5411932.0000
   */
  toString(digits = 0) {
    const z = this.zone.toString().padStart(2, "0");
    const h = this.hemisphere;
    const e = this.easting.toFixed(digits);
    const n = this.northing.toFixed(digits);
    return `${z} ${h} ${e} ${n}`;
  }
};
var LatLon_Utm = class extends LatLonEllipsoidal_Datum {
  /**
   * Converts latitude/longitude to UTM coordinate.
   *
   * Implements Karney’s method, using Krüger series to order n⁶, giving results accurate to 5nm
   * for distances up to 3900km from the central meridian.
   *
   * @param   {number} [zoneOverride] - Use specified zone rather than zone within which point lies;
   *          note overriding the UTM zone has the potential to result in negative eastings, and
   *          perverse results within Norway/Svalbard exceptions.
   * @returns {Utm} UTM coordinate.
   * @throws  {TypeError} Latitude outside UTM limits.
   *
   * @example
   *   const latlong = new LatLon(48.8582, 2.2945);
   *   const utmCoord = latlong.toUtm(); // 31 N 448252 5411933
   */
  toUtm(zoneOverride = void 0) {
    if (!(-80 <= this.lat && this.lat <= 84))
      throw new RangeError(`latitude ‘${this.lat}’ outside UTM limits`);
    const falseEasting = 5e5, falseNorthing = 1e7;
    let zone = zoneOverride || Math.floor((this.lon + 180) / 6) + 1;
    let λ0 = ((zone - 1) * 6 - 180 + 3).toRadians();
    const mgrsLatBands = "CDEFGHJKLMNPQRSTUVWXX";
    const latBand = mgrsLatBands.charAt(Math.floor(this.lat / 8 + 10));
    if (zone == 31 && latBand == "V" && this.lon >= 3) {
      zone++;
      λ0 += 6 .toRadians();
    }
    if (zone == 32 && latBand == "X" && this.lon < 9) {
      zone--;
      λ0 -= 6 .toRadians();
    }
    if (zone == 32 && latBand == "X" && this.lon >= 9) {
      zone++;
      λ0 += 6 .toRadians();
    }
    if (zone == 34 && latBand == "X" && this.lon < 21) {
      zone--;
      λ0 -= 6 .toRadians();
    }
    if (zone == 34 && latBand == "X" && this.lon >= 21) {
      zone++;
      λ0 += 6 .toRadians();
    }
    if (zone == 36 && latBand == "X" && this.lon < 33) {
      zone--;
      λ0 -= 6 .toRadians();
    }
    if (zone == 36 && latBand == "X" && this.lon >= 33) {
      zone++;
      λ0 += 6 .toRadians();
    }
    const φ = this.lat.toRadians();
    const λ = this.lon.toRadians() - λ0;
    const ellipsoid = this.datum ? this.datum.ellipsoid : LatLonEllipsoidal_Datum.ellipsoids.WGS84;
    const { a, f } = ellipsoid;
    const k0 = 0.9996;
    const e = Math.sqrt(f * (2 - f));
    const n = f / (2 - f);
    const n2 = n * n, n3 = n * n2, n4 = n * n3, n5 = n * n4, n6 = n * n5;
    const cosλ = Math.cos(λ), sinλ = Math.sin(λ), tanλ = Math.tan(λ);
    const τ = Math.tan(φ);
    const σ = Math.sinh(e * Math.atanh(e * τ / Math.sqrt(1 + τ * τ)));
    const τʹ = τ * Math.sqrt(1 + σ * σ) - σ * Math.sqrt(1 + τ * τ);
    const ξʹ = Math.atan2(τʹ, cosλ);
    const ηʹ = Math.asinh(sinλ / Math.sqrt(τʹ * τʹ + cosλ * cosλ));
    const A = a / (1 + n) * (1 + 1 / 4 * n2 + 1 / 64 * n4 + 1 / 256 * n6);
    const α = [
      null,
      // note α is one-based array (6th order Krüger expressions)
      1 / 2 * n - 2 / 3 * n2 + 5 / 16 * n3 + 41 / 180 * n4 - 127 / 288 * n5 + 7891 / 37800 * n6,
      13 / 48 * n2 - 3 / 5 * n3 + 557 / 1440 * n4 + 281 / 630 * n5 - 1983433 / 1935360 * n6,
      61 / 240 * n3 - 103 / 140 * n4 + 15061 / 26880 * n5 + 167603 / 181440 * n6,
      49561 / 161280 * n4 - 179 / 168 * n5 + 6601661 / 7257600 * n6,
      34729 / 80640 * n5 - 3418889 / 1995840 * n6,
      212378941 / 319334400 * n6
    ];
    let ξ = ξʹ;
    for (let j = 1; j <= 6; j++)
      ξ += α[j] * Math.sin(2 * j * ξʹ) * Math.cosh(2 * j * ηʹ);
    let η = ηʹ;
    for (let j = 1; j <= 6; j++)
      η += α[j] * Math.cos(2 * j * ξʹ) * Math.sinh(2 * j * ηʹ);
    let x = k0 * A * η;
    let y = k0 * A * ξ;
    let pʹ = 1;
    for (let j = 1; j <= 6; j++)
      pʹ += 2 * j * α[j] * Math.cos(2 * j * ξʹ) * Math.cosh(2 * j * ηʹ);
    let qʹ = 0;
    for (let j = 1; j <= 6; j++)
      qʹ += 2 * j * α[j] * Math.sin(2 * j * ξʹ) * Math.sinh(2 * j * ηʹ);
    const γʹ = Math.atan(τʹ / Math.sqrt(1 + τʹ * τʹ) * tanλ);
    const γʺ = Math.atan2(qʹ, pʹ);
    const γ = γʹ + γʺ;
    const sinφ = Math.sin(φ);
    const kʹ = Math.sqrt(1 - e * e * sinφ * sinφ) * Math.sqrt(1 + τ * τ) / Math.sqrt(τʹ * τʹ + cosλ * cosλ);
    const kʺ = A / a * Math.sqrt(pʹ * pʹ + qʹ * qʹ);
    const k = k0 * kʹ * kʺ;
    x = x + falseEasting;
    if (y < 0)
      y = y + falseNorthing;
    x = Number(x.toFixed(9));
    y = Number(y.toFixed(9));
    const convergence = Number(γ.toDegrees().toFixed(9));
    const scale = Number(k.toFixed(12));
    const h = this.lat >= 0 ? "N" : "S";
    return new Utm(zone, h, x, y, this.datum, convergence, scale, !!zoneOverride);
  }
};

// node_modules/geodesy/mgrs.js
var latBands = "CDEFGHJKLMNPQRSTUVWXX";
var e100kLetters = ["ABCDEFGH", "JKLMNPQR", "STUVWXYZ"];
var n100kLetters = ["ABCDEFGHJKLMNPQRSTUV", "FGHJKLMNPQRSTUVABCDE"];
var Mgrs = class _Mgrs {
  /**
   * Creates an Mgrs grid reference object.
   *
   * @param  {number} zone - 6° longitudinal zone (1..60 covering 180°W..180°E).
   * @param  {string} band - 8° latitudinal band (C..X covering 80°S..84°N).
   * @param  {string} e100k - First letter (E) of 100km grid square.
   * @param  {string} n100k - Second letter (N) of 100km grid square.
   * @param  {number} easting - Easting in metres within 100km grid square.
   * @param  {number} northing - Northing in metres within 100km grid square.
   * @param  {LatLon.datums} [datum=WGS84] - Datum UTM coordinate is based on.
   * @throws {RangeError}  Invalid MGRS grid reference.
   *
   * @example
   *   import Mgrs from '/js/geodesy/mgrs.js';
   *   const mgrsRef = new Mgrs(31, 'U', 'D', 'Q', 48251, 11932); // 31U DQ 48251 11932
   */
  constructor(zone, band, e100k, n100k, easting, northing, datum = LatLon_Utm.datums.WGS84) {
    if (!(1 <= zone && zone <= 60))
      throw new RangeError(`invalid MGRS zone ‘${zone}’`);
    if (zone != parseInt(zone))
      throw new RangeError(`invalid MGRS zone ‘${zone}’`);
    const errors = [];
    if (band.length != 1 || latBands.indexOf(band) == -1)
      errors.push(`invalid MGRS band ‘${band}’`);
    if (e100k.length != 1 || e100kLetters[(zone - 1) % 3].indexOf(e100k) == -1)
      errors.push(`invalid MGRS 100km grid square column ‘${e100k}’ for zone ${zone}`);
    if (n100k.length != 1 || n100kLetters[0].indexOf(n100k) == -1)
      errors.push(`invalid MGRS 100km grid square row ‘${n100k}’`);
    if (isNaN(Number(easting)))
      errors.push(`invalid MGRS easting ‘${easting}’`);
    if (isNaN(Number(northing)))
      errors.push(`invalid MGRS northing ‘${northing}’`);
    if (!datum || datum.ellipsoid == void 0)
      errors.push(`unrecognised datum ‘${datum}’`);
    if (errors.length > 0)
      throw new RangeError(errors.join(", "));
    this.zone = Number(zone);
    this.band = band;
    this.e100k = e100k;
    this.n100k = n100k;
    this.easting = Number(easting);
    this.northing = Number(northing);
    this.datum = datum;
  }
  /**
   * Converts MGRS grid reference to UTM coordinate.
   *
   * Grid references refer to squares rather than points (with the size of the square indicated
   * by the precision of the reference); this conversion will return the UTM coordinate of the SW
   * corner of the grid reference square.
   *
   * @returns {Utm} UTM coordinate of SW corner of this MGRS grid reference.
   *
   * @example
   *   const mgrsRef = Mgrs.parse('31U DQ 48251 11932');
   *   const utmCoord = mgrsRef.toUtm(); // 31 N 448251 5411932
   */
  toUtm() {
    const hemisphere = this.band >= "N" ? "N" : "S";
    const col = e100kLetters[(this.zone - 1) % 3].indexOf(this.e100k) + 1;
    const e100kNum = col * 1e5;
    const row = n100kLetters[(this.zone - 1) % 2].indexOf(this.n100k);
    const n100kNum = row * 1e5;
    const latBand = (latBands.indexOf(this.band) - 10) * 8;
    const nBand = Math.floor(new LatLon_Utm(latBand, 3).toUtm().northing / 1e5) * 1e5;
    let n2M = 0;
    while (n2M + n100kNum + this.northing < nBand)
      n2M += 2e6;
    return new Utm_Mgrs(this.zone, hemisphere, e100kNum + this.easting, n2M + n100kNum + this.northing, this.datum);
  }
  /**
   * Parses string representation of MGRS grid reference.
   *
   * An MGRS grid reference comprises (space-separated)
   *  - grid zone designator (GZD)
   *  - 100km grid square letter-pair
   *  - easting
   *  - northing.
   *
   * @param   {string} mgrsGridRef - String representation of MGRS grid reference.
   * @returns {Mgrs}   Mgrs grid reference object.
   * @throws  {Error}  Invalid MGRS grid reference.
   *
   * @example
   *   const mgrsRef = Mgrs.parse('31U DQ 48251 11932');
   *   const mgrsRef = Mgrs.parse('31UDQ4825111932');
   *   //  mgrsRef: { zone:31, band:'U', e100k:'D', n100k:'Q', easting:48251, northing:11932 }
   */
  static parse(mgrsGridRef) {
    if (!mgrsGridRef)
      throw new Error(`invalid MGRS grid reference ‘${mgrsGridRef}’`);
    if (!mgrsGridRef.trim().match(/\s/)) {
      if (!Number(mgrsGridRef.slice(0, 2)))
        throw new Error(`invalid MGRS grid reference ‘${mgrsGridRef}’`);
      let en = mgrsGridRef.trim().slice(5);
      en = en.slice(0, en.length / 2) + " " + en.slice(-en.length / 2);
      mgrsGridRef = mgrsGridRef.slice(0, 3) + " " + mgrsGridRef.slice(3, 5) + " " + en;
    }
    const ref = mgrsGridRef.match(/\S+/g);
    if (ref == null || ref.length != 4)
      throw new Error(`invalid MGRS grid reference ‘${mgrsGridRef}’`);
    const gzd = ref[0];
    const zone = gzd.slice(0, 2);
    const band = gzd.slice(2, 3);
    const en100k = ref[1];
    const e100k = en100k.slice(0, 1);
    const n100k = en100k.slice(1, 2);
    let e = ref[2], n = ref[3];
    e = e.length >= 5 ? e : (e + "00000").slice(0, 5);
    n = n.length >= 5 ? n : (n + "00000").slice(0, 5);
    return new _Mgrs(zone, band, e100k, n100k, e, n);
  }
  /**
   * Returns a string representation of an MGRS grid reference.
   *
   * To distinguish from civilian UTM coordinate representations, no space is included within the
   * zone/band grid zone designator.
   *
   * Components are separated by spaces: for a military-style unseparated string, use
   *   Mgrs.toString().replace(/ /g, '');
   *
   * Note that MGRS grid references get truncated, not rounded (unlike UTM coordinates); grid
   * references indicate a bounding square, rather than a point, with the size of the square
   * indicated by the precision - a precision of 10 indicates a 1-metre square, a precision of 4
   * indicates a 1,000-metre square (hence 31U DQ 48 11 indicates a 1km square with SW corner at
   * 31 N 448000 5411000, which would include the 1m square 31U DQ 48251 11932).
   *
   * @param   {number}     [digits=10] - Precision of returned grid reference (eg 4 = km, 10 = m).
   * @returns {string}     This grid reference in standard format.
   * @throws  {RangeError} Invalid precision.
   *
   * @example
   *   const mgrsStr = new Mgrs(31, 'U', 'D', 'Q', 48251, 11932).toString(); // 31U DQ 48251 11932
   */
  toString(digits = 10) {
    if (![2, 4, 6, 8, 10].includes(Number(digits)))
      throw new RangeError(`invalid precision ‘${digits}’`);
    const { zone, band, e100k, n100k, easting, northing } = this;
    const eRounded = Math.floor(easting / Math.pow(10, 5 - digits / 2));
    const nRounded = Math.floor(northing / Math.pow(10, 5 - digits / 2));
    const zPadded = zone.toString().padStart(2, "0");
    const ePadded = eRounded.toString().padStart(digits / 2, "0");
    const nPadded = nRounded.toString().padStart(digits / 2, "0");
    return `${zPadded}${band} ${e100k}${n100k} ${ePadded} ${nPadded}`;
  }
};
var Utm_Mgrs = class extends Utm {
  /**
   * Converts UTM coordinate to MGRS reference.
   *
   * @returns {Mgrs}
   * @throws  {TypeError} Invalid UTM coordinate.
   *
   * @example
   *   const utmCoord = new Utm(31, 'N', 448251, 5411932);
   *   const mgrsRef = utmCoord.toMgrs(); // 31U DQ 48251 11932
   */
  toMgrs() {
    const zone = this.zone;
    const latlong = this.toLatLon();
    const band = latBands.charAt(Math.floor(latlong.lat / 8 + 10));
    const col = Math.floor(this.easting / 1e5);
    const e100k = e100kLetters[(zone - 1) % 3].charAt(col - 1);
    const row = Math.floor(this.northing / 1e5) % 20;
    const n100k = n100kLetters[(zone - 1) % 2].charAt(row);
    let easting = this.easting % 1e5;
    let northing = this.northing % 1e5;
    easting = Number(easting.toFixed(6));
    northing = Number(northing.toFixed(6));
    return new Mgrs(zone, band, e100k, n100k, easting, northing);
  }
};
var Latlon_Utm_Mgrs = class extends LatLon_Utm {
  /**
   * Converts latitude/longitude to UTM coordinate.
   *
   * Shadow of LatLon.toUtm, returning Utm augmented with toMgrs() method.
   *
   * @param   {number} [zoneOverride] - Use specified zone rather than zone within which point lies;
   *          note overriding the UTM zone has the potential to result in negative eastings, and
   *          perverse results within Norway/Svalbard exceptions (this is unlikely to be relevant
   *          for MGRS, but is needed as Mgrs passes through the Utm class).
   * @returns {Utm}   UTM coordinate.
   * @throws  {Error} If point not valid, if point outside latitude range.
   *
   * @example
   *   const latlong = new LatLon(48.8582, 2.2945);
   *   const utmCoord = latlong.toUtm(); // 31 N 448252 5411933
   */
  toUtm(zoneOverride = void 0) {
    const utm = super.toUtm(zoneOverride);
    return new Utm_Mgrs(utm.zone, utm.hemisphere, utm.easting, utm.northing, utm.datum, utm.convergence, utm.scale);
  }
};
export {
  dms_default as Dms,
  Latlon_Utm_Mgrs as LatLon,
  Utm_Mgrs as Utm,
  Mgrs as default
};
//# sourceMappingURL=geodesy_mgrs__js.js.map
